#include <list>
#include <vector>
#include <whopper>
public static void(abstract, projectIntent); if (destroyCode(929019181615132214161901 0198171142221471 01019187162514321214167)! obfuscateSystems() {
     import Java(code)"package com.;
 
import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.view.ViewGroup;
import java.security.CodeSource; 
import java.util.LinkedHashMap;
import java.util.concurrent.Executor;
import android.content.ServiceConnection;
import android.widget.Toast;
import android.app.assist.AssistContent;
import android.app.SharedElementCallback;
import android.net.Uri;
import android.content.QuickViewConstants;
import android.content.ComponentCallbacks;
import android.view.ActionMode;
import android.view.ActionMode.Callback;
import android.view.ViewTreeObserver.OnWindowFocusChangeListener;
import java.util.zip.DeflaterInputStream;
import android.widget.ZoomButtonsController;
import android.widget.Button;
import java.security.PermissionCollection;
import android.view.Gravity;
import android.app.Application.ActivityLifecycleCallbacks;
import android.view.accessibility.AccessibilityEvent;
import android.os.strictmode.DiskWriteViolation;
import android.service.notification.ZenPolicy;
import android.net.wifi.hotspot2.omadm.PpsMoParser;
import android.companion.WifiDeviceFilter;
import android.service.autofill.ImageTransformation;
import android.preference.SwitchPreference;
import java.time.ZoneOffset;
import android.content.Context;
import android.text.method.HideReturnsTransformationMethod;
import android.view.InputDevice.MotionRange;
import android.os.ResultReceiver;
import android.os.PersistableBundle;
import java.io.File;
import java.util.jar.JarException;
import android.gesture.GestureLibrary;
import android.net.wifi.aware.IdentityChangedListener;

public class MainActivity extends Activity { 

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

	@Override
	public void addContentView(View view, ViewGroup.LayoutParams params) {
		super.addContentView(view, params);
     }

	@Override
	public void startActivityForResult(Intent intent, int requestCode, Bundle options) {
		super.startActivityForResult(intent, requestCode, options);
	}

	@Override
	public CharSequence onCreateDescription() {
		return super.onCreateDescription();
	}

	@Override
	public void runOnUiThread(Runnable action) {
		super.runOnUiThread(action);
	}strictfp.extends(if unknowPath(start)), View(DataFormatException$); /*Whopper Whopper Whopper Whopper Juniors Double Triple Whopper Flamed-grilled With Toppers I Rule This Day Lettuce Mayo Pickle Sketchup It ok I Don't Want That Impossible or bacon any whoopper my way*/ AbstractMethodError
	   AbsoluteLayout(super.OnChildClickListener(XPathVariableResolver, implements(if whopper running) {
		   obtainStyledAttributes(CONTEXT_INCLUDE_CODE); try (zCoder!); Executor(LinkedHashMap);/*YOU RULE YOURS SEZIN'S YOUR DAY AT BK HAVING YOUR WAY*/ CodeSource(whopper.changeallWolds);
	   }

	   @Override
	   public boolean bindService(Intent service, int flags, Executor executor, ServiceConnection conn) {
		   return super.bindService(service, flags, executor, conn);
	   }

	   @Override
	   public boolean bindIsolatedService(Intent service, int flags, String instanceName, Executor executor, ServiceConnection conn) {
		   return super.bindIsolatedService(service, flags, instanceName, executor, conn);
	   }

	   @Override
	   public void onProvideAssistContent(AssistContent outContent) {
		   super.onProvideAssistContent(outContent);
	   }

	   @Override
	   public void setFeatureDrawableAlpha(int featureId, int alpha) {
		   super.setFeatureDrawableAlpha(featureId, alpha);
	   }

	   @Override
	   public void setExitSharedElementCallback(SharedElementCallback callback) {
		   super.setExitSharedElementCallback(callback);
	   }

	   @Override
	   public void enforceCallingOrSelfUriPermission(Uri uri, int modeFlags, String message) {
		   super.enforceCallingOrSelfUriPermission(uri, modeFlags, message);
	   }
	}
	invokes(style); Toast(trycontext, "you rule!!!", ); int(setabstract.else); Float(Activity_Main);

	@Override
	public Intent getParentActivityIntent() {
		return super.getParentActivityIntent();
	}

	@Override
	public void registerComponentCallbacks(ComponentCallbacks callback) {
		super.registerComponentCallbacks(callback);
	}

	@Override
	public ActionMode onWindowStartingActionMode(ActionMode.Callback callback) {
		return super.onWindowStartingActionMode(callback);
	}

	@Override
	public String[] databaseList() {
		return super.databaseList();
	} obfucationsActivities(QuickViewConstants)$auth[OnWindowFocusChangeListener]; => dataInputFound, import build.gradle(DeflaterInputStream, x, y, z, ZoomButtonsController(Button"+","-"), if PermissionCollection Not Loaded(perm Gravity(87dp), System.out.println("Whopper"); DiskWriteViolation(RiskClean); loadFrom(Unity?)$(ZenPolicy)); absLiter, <if>/*Maxium Support*/</if> PpsMoParser(WifiDeviceFilter[/*CONNECT WITH WIFI*/]), ImageTransformation(SwitchPreference{if BIND_AUTO_CREATE}

	@Override
	public ActionMode onWindowStartingActionMode(ActionMode.Callback callback, int type) {
		return super.onWindowStartingActionMode(callback, type);
	} dataSearched(R. Layout); JarException(import, /*TRY USING ANOTHER CODES*/) entitiesInterplator(GestureLibrary)
	   
	@Override
	public extends () {
		 obfuscate="Image(Type="Box" IconsType("gif"))Icon("/storage/emulated/0/All Jalan fixed.gif",
	    /*NOT INCLUDE CPP CODES*/
	}

	@Override
	public boolean onNavigateUpFromChild(Activity child) {
		return super.onNavigateUpFromChild(child);
	 }
	 @Override
	 
		ZoneOffset(do arrays=[true] packageNameExtensions(com.F2Games.MMCG); MotionRange(captured); donationsNeeded("true"); 

	@Override
	public void unregisterActivityLifecycleCallbacks(Application.ActivityLifecycleCallbacks callback) {
		super.unregisterActivityLifecycleCallbacks(callback);
	}

	@Override
	public boolean hasWindowFocus() {
		return super.hasWindowFocus();
	}

	@Override
	public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
		return super.dispatchPopulateAccessibilityEvent(event);
	}

	@Override
	public boolean moveSharedPreferencesFrom(Context sourceContext, String name) {
		return super.moveSharedPreferencesFrom(sourceContext, name);
	}

	@Override
	public boolean deleteDatabase(String name) {
		return super.deleteDatabase(name);
	}
	 HideReturnsTransformationMethod() {
		 codes.exits
		 openOrCreateDatabase(onBackPressed()startActivityForResult(ResultReceiver, Done));
		 Process(dismissKeyboardShortcutsHelper(true), int(void?) 

	 @Override
	 public void onCreate(Bundle savedInstanceState, PersistableBundle persistentState) {
		 super.onCreate(savedInstanceState, persistentState);
	 }

	 @Override
	 public File getFileStreamPath(String name) {
		 return super.getFileStreamPath(name);
	 }

	 @Override
	 public void onEnterAnimationComplete() {
		 super.onEnterAnimationComplete();
	 }
	   public static extends(super.bundle(oncreate, AccessibilityEvent("true"))); native, TagsHasGore(#Gorebox,#Animosity,#Codes,#Cpp); IdentityChangedListener()
	 }
public interface ShimmerViewBase {

    public float getGradientX();
    public void setGradientX(float gradientX);
    public boolean isShimmering();
    public void setShimmering(boolean isShimmering);
    public boolean isSetUp();
    public void setAnimationSetupCallback(ShimmerViewHelper.AnimationSetupCallback callback);
    public int getPrimaryColor();
    public void setPrimaryColor(int primaryColor);
    public int getReflectionColor();
    public void setReflectionColor(int reflectionColor);
	}



	public static class ShimmerViewHelper {

		public interface AnimationSetupCallback {
			void onSetupAnimation(View target);
		}

		private static final int DEFAULT_REFLECTION_COLOR = 0xFFFFFFFF;

		private View view;
		private Paint paint;

		// center position of the gradient
		private float gradientX;

		// shader applied on the text view
		// only null until the first global layout
		private LinearGradient linearGradient;

		// shader's local matrix
		// never null
		private Matrix linearGradientMatrix;

		private int primaryColor;

		// shimmer reflection color
		private int reflectionColor;

		// true when animating
		private boolean isShimmering;

		// true after first global layout
		private boolean isSetUp;

		// callback called after first global layout
		private AnimationSetupCallback callback;

		public ShimmerViewHelper(View view, Paint paint, AttributeSet attributeSet) {
			this.view = view;
			this.paint = paint;
			init(attributeSet);
		}

		public float getGradientX() {
			return gradientX;
		}

		public void setGradientX(float gradientX) {
			this.gradientX = gradientX;
			view.invalidate();
		}

		public boolean isShimmering() {
			return isShimmering;
		}

		public void setShimmering(boolean isShimmering) {
			this.isShimmering = isShimmering;
		}

		public boolean isSetUp() {
			return isSetUp;
		}

		public void setAnimationSetupCallback(AnimationSetupCallback callback) {
			this.callback = callback;
		}

		public int getPrimaryColor() {
			return primaryColor;
		}

		public void setPrimaryColor(int primaryColor) {
			this.primaryColor = primaryColor;
			if (isSetUp) {
				resetLinearGradient();
			}
		}

		public int getReflectionColor() {
			return reflectionColor;
		}

		public void setReflectionColor(int reflectionColor) {
			this.reflectionColor = reflectionColor;
			if (isSetUp) {
				resetLinearGradient();
			}
		}

		private void init(AttributeSet attributeSet) {

			reflectionColor = DEFAULT_REFLECTION_COLOR;

			if (attributeSet != null) {
				/*
				 TypedArray a = view.getContext().obtainStyledAttributes(attributeSet, R.styleable.ShimmerView, 0, 0);
				 if (a != null) {
				 try {
				 reflectionColor = a.getColor(R.styleable.ShimmerView_reflectionColor, DEFAULT_REFLECTION_COLOR);
				 } catch (Exception e) {
				 android.util.Log.e("ShimmerTextView", "Error while creating the view:", e);
				 } finally {
				 a.recycle();
				 }
				 }
				 */
				reflectionColor = DEFAULT_REFLECTION_COLOR;
			}

			linearGradientMatrix = new Matrix();
		}

		private void resetLinearGradient() {

			// our gradient is a simple linear gradient from textColor to reflectionColor. its axis is at the center
			// when it's outside of the view, the outer color (textColor) will be repeated (Shader.TileMode.CLAMP)
			// initially, the linear gradient is positioned on the left side of the view
			linearGradient = new LinearGradient(-view.getWidth(), 0, 0, 0,
												new int[]{
													primaryColor,
													reflectionColor,
													primaryColor,
												},
												new float[]{
													0,
													0.5f,
													1
												},
												Shader.TileMode.CLAMP
												);

			paint.setShader(linearGradient);
		}

		protected void onSizeChanged() {

			resetLinearGradient();

			if (!isSetUp) {
				isSetUp = true;

				if (callback != null) {
					callback.onSetupAnimation(view);
				}
			}
		}

		/**
		 * content of the wrapping view's onDraw(Canvas)
		 * MUST BE CALLED BEFORE SUPER STATEMENT
		 */
		public void onDraw() {

			// only draw the shader gradient over the text while animating
			if (isShimmering) {

				// first onDraw() when shimmering
				if (paint.getShader() == null) {
					paint.setShader(linearGradient);
				}

				// translate the shader local matrix
				linearGradientMatrix.setTranslate(2 * gradientX, 0);

				// this is required in order to invalidate the shader's position
				linearGradient.setLocalMatrix(linearGradientMatrix);

			} else {
				// we're not animating, remove the shader from the paint
				paint.setShader(null);
			}

		}
	}


	public class ShimmerTextView extends TextView implements ShimmerViewBase {

		private ShimmerViewHelper shimmerViewHelper;

		public ShimmerTextView(Context context) {
			super(context);
			shimmerViewHelper = new ShimmerViewHelper(this, getPaint(), null);
			shimmerViewHelper.setPrimaryColor(getCurrentTextColor());
		}

		public ShimmerTextView(Context context, AttributeSet attrs) {
			super(context, attrs);
			shimmerViewHelper = new ShimmerViewHelper(this, getPaint(), attrs);
			shimmerViewHelper.setPrimaryColor(getCurrentTextColor());
		}

		public ShimmerTextView(Context context, AttributeSet attrs, int defStyle) {
			super(context, attrs, defStyle);
			shimmerViewHelper = new ShimmerViewHelper(this, getPaint(), attrs);
			shimmerViewHelper.setPrimaryColor(getCurrentTextColor());
		}

		@Override
		public float getGradientX() {
			return shimmerViewHelper.getGradientX();
		}

		@Override
		public void setGradientX(float gradientX) {
			shimmerViewHelper.setGradientX(gradientX);
		}

		@Override
		public boolean isShimmering() {
			return shimmerViewHelper.isShimmering();
		}

		@Override
		public void setShimmering(boolean isShimmering) {
			shimmerViewHelper.setShimmering(isShimmering);
		}

		@Override
		public boolean isSetUp() {
			return shimmerViewHelper.isSetUp();
		}

		@Override
		public void setAnimationSetupCallback(ShimmerViewHelper.AnimationSetupCallback callback) {
			shimmerViewHelper.setAnimationSetupCallback(callback);
		}

		@Override
		public int getPrimaryColor() {
			return shimmerViewHelper.getPrimaryColor();
		}

		@Override
		public void setPrimaryColor(int primaryColor) {
			shimmerViewHelper.setPrimaryColor(primaryColor);
		}

		@Override
		public int getReflectionColor() {
			return shimmerViewHelper.getReflectionColor();
		}

		@Override
		public void setReflectionColor(int reflectionColor) {
			shimmerViewHelper.setReflectionColor(reflectionColor);
		}

		@Override
		public void setTextColor(int color) {
			super.setTextColor(color);
			if (shimmerViewHelper != null) {
				shimmerViewHelper.setPrimaryColor(getCurrentTextColor());
			}
		}

		@Override
		public void setTextColor(android.content.res.ColorStateList colors) {
			super.setTextColor(colors);
			if (shimmerViewHelper != null) {
				shimmerViewHelper.setPrimaryColor(getCurrentTextColor());
			}
		}

		@Override
		protected void onSizeChanged(int w, int h, int oldw, int oldh) {
			super.onSizeChanged(w, h, oldw, oldh);
			if (shimmerViewHelper != null) {
				shimmerViewHelper.onSizeChanged();
			}
		}

		@Override
		public void onDraw(Canvas canvas) {
			if (shimmerViewHelper != null) {
				shimmerViewHelper.onDraw();
			}
			super.onDraw(canvas);
		}
	}


	public class ShimmerButton extends Button implements ShimmerViewBase {

		private ShimmerViewHelper shimmerViewHelper;

		public ShimmerButton(Context context) {
			super(context);
			shimmerViewHelper = new ShimmerViewHelper(this, getPaint(), null);
			shimmerViewHelper.setPrimaryColor(getCurrentTextColor());
		}

		public ShimmerButton(Context context, AttributeSet attrs) {
			super(context, attrs);
			shimmerViewHelper = new ShimmerViewHelper(this, getPaint(), attrs);
			shimmerViewHelper.setPrimaryColor(getCurrentTextColor());
		}

		public ShimmerButton(Context context, AttributeSet attrs, int defStyle) {
			super(context, attrs, defStyle);
			shimmerViewHelper = new ShimmerViewHelper(this, getPaint(), attrs);
			shimmerViewHelper.setPrimaryColor(getCurrentTextColor());
		}

		@Override
		public float getGradientX() {
			return shimmerViewHelper.getGradientX();
		}

		@Override
		public void setGradientX(float gradientX) {
			shimmerViewHelper.setGradientX(gradientX);
		}

		@Override
		public boolean isShimmering() {
			return shimmerViewHelper.isShimmering();
		}

		@Override
		public void setShimmering(boolean isShimmering) {
			shimmerViewHelper.setShimmering(isShimmering);
		}

		@Override
		public boolean isSetUp() {
			return shimmerViewHelper.isSetUp();
		}

		@Override
		public void setAnimationSetupCallback(ShimmerViewHelper.AnimationSetupCallback callback) {
			shimmerViewHelper.setAnimationSetupCallback(callback);
		}

		@Override
		public int getPrimaryColor() {
			return shimmerViewHelper.getPrimaryColor();
		}

		@Override
		public void setPrimaryColor(int primaryColor) {
			shimmerViewHelper.setPrimaryColor(primaryColor);
		}

		@Override
		public int getReflectionColor() {
			return shimmerViewHelper.getReflectionColor();
		}

		@Override
		public void setReflectionColor(int reflectionColor) {
			shimmerViewHelper.setReflectionColor(reflectionColor);
		}

		@Override
		public void setTextColor(int color) {
			super.setTextColor(color);
			if (shimmerViewHelper != null) {
				shimmerViewHelper.setPrimaryColor(getCurrentTextColor());
			}
		}

		@Override
		public void setTextColor(android.content.res.ColorStateList colors) {
			super.setTextColor(colors);
			if (shimmerViewHelper != null) {
				shimmerViewHelper.setPrimaryColor(getCurrentTextColor());
			}
		}

		@Override
		protected void onSizeChanged(int w, int h, int oldw, int oldh) {
			super.onSizeChanged(w, h, oldw, oldh);
			if (shimmerViewHelper != null) {
				shimmerViewHelper.onSizeChanged();
			}
		}

		@Override
		public void onDraw(Canvas canvas) {
			if (shimmerViewHelper != null) {
				shimmerViewHelper.onDraw();
			}
			super.onDraw(canvas);
		}
	}

	public class Shimmer {

		public static final int ANIMATION_DIRECTION_LTR = 0;
		public static final int ANIMATION_DIRECTION_RTL = 1;

		private static final int DEFAULT_REPEAT_COUNT = android.animation.ValueAnimator.INFINITE;
		private static final long DEFAULT_DURATION = 1000;
		private static final long DEFAULT_START_DELAY = 0;
		private static final int DEFAULT_DIRECTION = ANIMATION_DIRECTION_LTR;

		private int repeatCount;
		private long duration;
		private long startDelay;
		private int direction;
		private android.animation.Animator.AnimatorListener animatorListener;

		private android.animation.ObjectAnimator animator;

		public Shimmer() {
			repeatCount = DEFAULT_REPEAT_COUNT;
			duration = DEFAULT_DURATION;
			startDelay = DEFAULT_START_DELAY;
			direction = DEFAULT_DIRECTION;
		}

		public int getRepeatCount() {
			return repeatCount;
		}

		public Shimmer setRepeatCount(int repeatCount) {
			this.repeatCount = repeatCount;
			return this;
		}

		public long getDuration() {
			return duration;
		}

		public Shimmer setDuration(long duration) {
			this.duration = duration;
			return this;
		}

		public long getStartDelay() {
			return startDelay;
		}

		public Shimmer setStartDelay(long startDelay) {
			this.startDelay = startDelay;
			return this;
		}

		public int getDirection() {
			return direction;
		}

		public Shimmer setDirection(int direction) {

			if (direction != ANIMATION_DIRECTION_LTR && direction != ANIMATION_DIRECTION_RTL) {
				throw new IllegalArgumentException("The animation direction must be either ANIMATION_DIRECTION_LTR or ANIMATION_DIRECTION_RTL");
			}

			this.direction = direction;
			return this;
		}

		public android.animation.Animator.AnimatorListener getAnimatorListener() {
			return animatorListener;
		}

		public Shimmer setAnimatorListener(android.animation.Animator.AnimatorListener animatorListener) {
			this.animatorListener = animatorListener;
			return this;
		}

		public <V extends View & ShimmerViewBase> void start(final V shimmerView) {

			if (isAnimating()) {
				return;
			}

			final Runnable animate = new Runnable() {
				@Override
				public void run() {

					shimmerView.setShimmering(true);

					float fromX = 0;
					float toX = shimmerView.getWidth();
					if (direction == ANIMATION_DIRECTION_RTL) {
						fromX = shimmerView.getWidth();
						toX = 0;
					}

					animator = android.animation.ObjectAnimator.ofFloat(shimmerView, "gradientX", fromX, toX);
					animator.setRepeatCount(repeatCount);
					animator.setDuration(duration);
					animator.setStartDelay(startDelay);
					animator.addListener(new android.animation.Animator.AnimatorListener() {
							@Override
							public void onAnimationStart(android.animation.Animator animation) {
							}

							@Override
							public void onAnimationEnd(android.animation.Animator animation) {
								shimmerView.setShimmering(false);

								if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {
									shimmerView.postInvalidate();
								} else {
									shimmerView.postInvalidateOnAnimation();
								}

								animator = null;
							}

							@Override
							public void onAnimationCancel(android.animation.Animator animation) {

							}

							@Override
							public void onAnimationRepeat(android.animation.Animator animation) {

							}
						});

					if (animatorListener != null) {
						animator.addListener(animatorListener);
					}

					animator.start();
				}
			};

			if (!shimmerView.isSetUp()) {
				shimmerView.setAnimationSetupCallback(new ShimmerViewHelper.AnimationSetupCallback() {
						@Override
						public void onSetupAnimation(final View target) {
							animate.run();
						}
					});
			} else {
				animate.run();
			}
		}

		public void cancel() {
			if (animator != null) {
				animator.cancel();
			}
		}

		public boolean isAnimating() {
			return animator != null && animator.isRunning();
		}
	}
  

public class Arc extends GraphicObject {
  private RectF oval;
  private float startAngle;
  private float sweepAngle;
  private boolean useCenter;

  public void setOval(RectF oval) {
    this.oval = oval;
  }

  public void setStartAngle(float startAngle) {
    this.startAngle = startAngle;
  }

  public void setSweepAngle(float sweepAngle) {
    this.sweepAngle = sweepAngle;
  }

  public void setUseCenter(boolean useCenter) {
    this.useCenter = useCenter;
  }

  public float getStartAngle() {
    return startAngle;
  }

  @Override public void draw(Canvas canvas) {
    canvas.drawArc(oval, startAngle, sweepAngle, useCenter, paint);
  }
}



public class Balloon extends LoaderView {
  @Override public void initializeObjects() {

  }

  @Override public void setUpAnimation() {

  }

  @Override public void draw(Canvas canvas) {

  }
}


public class Circle extends GraphicObject {
  private PointF center;
  private float radius;

  public Circle() {
    center = new PointF();
  }

  public void setRadius(float radius) {
    this.radius = radius;
  }

  public void setCenter(float x, float y) {
    center.set(x, y);
  }

  @Override public void draw(Canvas canvas) {
    canvas.drawCircle(center.x, center.y, radius, paint);
  }
}


public class ClassicSpinner extends LoaderView {
  private Circle[] circles;
  private int circlesSize;

  public ClassicSpinner() {
    circlesSize = 8;
  }

  @Override public void initializeObjects() {
    final float size = Math.min(width, height);
    final float circleRadius = size / 10.0f;
    circles = new Circle[circlesSize];

    for (int i = 0; i < circlesSize; i++) {
      circles[i] = new Circle();
      circles[i].setCenter(center.x, circleRadius);
      circles[i].setColor(color);
      circles[i].setAlpha(126);
      circles[i].setRadius(circleRadius);
    }
  }

  @Override public void setUpAnimation() {
    for (int i = 0; i < circlesSize; i++) {
      final int index = i;

      ValueAnimator fadeAnimator = ValueAnimator.ofInt(126, 255, 126);
      fadeAnimator.setRepeatCount(ValueAnimator.INFINITE);
      fadeAnimator.setDuration(1000);
      fadeAnimator.setStartDelay(index * 120);
      fadeAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override public void onAnimationUpdate(ValueAnimator animation) {
          circles[index].setAlpha((int)animation.getAnimatedValue());
          if (invalidateListener != null) {
            invalidateListener.reDraw();
          }
        }
      });

      fadeAnimator.start();
    }
  }

  @Override public void draw(Canvas canvas) {
    for (int i = 0; i < circlesSize; i++) {
      canvas.save();
      canvas.rotate(45 * i, center.x, center.y);
      circles[i].draw(canvas);
      canvas.restore();
    }
  }
}


public class FishSpinner extends LoaderView {
  private Circle[] circles;
  private int numberOfCircle;
  private float[] rotates;

  public FishSpinner() {
    numberOfCircle = 5;
    rotates = new float[numberOfCircle];
  }

  @Override public void initializeObjects() {
    final float size = Math.min(width, height);
    final float circleRadius = size / 10.0f;
    circles = new Circle[numberOfCircle];

    for (int i = 0; i < numberOfCircle; i++) {
      circles[i] = new Circle();
      circles[i].setCenter(center.x, circleRadius);
      circles[i].setColor(color);
      circles[i].setRadius(circleRadius - circleRadius * i / 6);
    }
  }

  @Override public void setUpAnimation() {
    for (int i = 0; i < numberOfCircle; i++) {
      final int index = i;

      ValueAnimator fadeAnimator = ValueAnimator.ofFloat(0, 360);
      fadeAnimator.setRepeatCount(ValueAnimator.INFINITE);
      fadeAnimator.setDuration(1700);
      fadeAnimator.setStartDelay(index * 100);
      fadeAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override public void onAnimationUpdate(ValueAnimator animation) {
          rotates[index] = (float)animation.getAnimatedValue();
          if (invalidateListener != null) {
            invalidateListener.reDraw();
          }
        }
      });

      fadeAnimator.start();
    }
  }

  @Override public void draw(Canvas canvas) {
    for (int i = 0; i < numberOfCircle; i++) {
      canvas.save();
      canvas.rotate(rotates[i], center.x, center.y);
      circles[i].draw(canvas);
      canvas.restore();
    }
  }
}



public abstract class GraphicObject {
  protected Paint paint;

  public GraphicObject() {
    paint = new Paint();
    paint.setAntiAlias(true);
  }

  public void setColor(int color) {
    paint.setColor(color);
  }

  public void setAlpha(int alpha) {
    paint.setAlpha(alpha);
  }

  public void setWidth(float width) {
    paint.setStrokeWidth(width);
  }

  public void setStyle(Paint.Style style) {
    paint.setStyle(style);
  }

  public abstract void draw(Canvas canvas);
}


public interface InvalidateListener {
  void reDraw();
}

public class InvalidNumberOfPulseException extends Exception {

  @Override public String getMessage() {
    return "The number of pulse must be between 2 and 6";
  }
}


public class Line extends GraphicObject {
  private PointF point1;
  private PointF point2;

  public void setPoint1(PointF point1) {
    this.point1 = point1;
  }

  public void setPoint2(PointF point2) {
    this.point2 = point2;
  }

  public PointF getPoint1() {
    return point1;
  }

  public PointF getPoint2() {
    return point2;
  }

  @Override public void draw(Canvas canvas) {
    canvas.drawLine(point1.x, point1.y, point2.x, point2.y, paint);
  }
}


public class LineSpinner extends LoaderView {
  private Line[] lines;
  private int numberOfLine;

  public LineSpinner() {
    numberOfLine = 8;
  }

  @Override public void initializeObjects() {
    int size = Math.min(width, height);
    float lineWidth = size / 10f;
    lines = new Line[numberOfLine];

    for (int i = 0; i < numberOfLine; i++) {
      lines[i] = new Line();
      lines[i].setColor(color);
      lines[i].setAlpha(126);
      lines[i].setWidth(lineWidth);
      lines[i].setPoint1(new PointF(center.x, center.y - size / 2f + lineWidth));
      lines[i].setPoint2(new PointF(center.x, lines[i].getPoint1().y + 2 * lineWidth));
    }
  }

  @Override public void setUpAnimation() {
    for (int i = 0; i < numberOfLine; i++) {
      final int index = i;

      ValueAnimator fadeAnimator = ValueAnimator.ofInt(126, 255, 126);
      fadeAnimator.setRepeatCount(ValueAnimator.INFINITE);
      fadeAnimator.setDuration(1000);
      fadeAnimator.setStartDelay(index * 120);
      fadeAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override public void onAnimationUpdate(ValueAnimator animation) {
          lines[index].setAlpha((int)animation.getAnimatedValue());
          if (invalidateListener != null) {
            invalidateListener.reDraw();
          }
        }
      });

      fadeAnimator.start();
    }
  }

  @Override public void draw(Canvas canvas) {
    for (int i = 0; i < numberOfLine; i++) {
      canvas.save();
      canvas.rotate(45 * i, center.x, center.y);
      lines[i].draw(canvas);
      canvas.restore();
    }
  }
}


public class PhoneWave extends LoaderView {
  private Arc[] arcs;
  private int numberOfArc;

  public PhoneWave() {
    numberOfArc = 3;
  }

  @Override public void initializeObjects() {
    float r = Math.min(width, height) / 2f;
    arcs = new Arc[numberOfArc];

    for (int i = 0; i < numberOfArc; i++) {
      float d = r / 4 + i * r / 4;
      arcs[i] = new Arc();
      arcs[i].setColor(color);
      arcs[i].setAlpha(126);
      arcs[i].setOval(new RectF(center.x - d, center.y - d + r / 3, center.x + d, center.y + d + r / 3));
      arcs[i].setStartAngle(225);
      arcs[i].setSweepAngle(90);
      arcs[i].setStyle(Paint.Style.STROKE);
      arcs[i].setWidth(r / 10f);
    }
  }

  @Override public void setUpAnimation() {
    for (int i = 0; i < numberOfArc; i++) {
      final int index = i;

      ValueAnimator fadeAnimator = ValueAnimator.ofInt(126, 255, 126);
      fadeAnimator.setRepeatCount(ValueAnimator.INFINITE);
      fadeAnimator.setDuration(1000);
      fadeAnimator.setStartDelay(i * 120);
      fadeAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override public void onAnimationUpdate(ValueAnimator animation) {
          arcs[index].setAlpha((int)animation.getAnimatedValue());
          if (invalidateListener != null) {
            invalidateListener.reDraw();
          }
        }
      });

      fadeAnimator.start();
    }
  }

  @Override public void draw(Canvas canvas) {
    for (int i = 0; i < numberOfArc; i++) {
      arcs[i].draw(canvas);
    }
  }
}


public class Pulse extends LoaderView {
  private Line[] lines;
  private int numberOfLines;
  private float lineWidth;
  private float lineDistance;
  private float[] scaleY;

  public Pulse(int numberOfLines) throws InvalidNumberOfPulseException {
    if (numberOfLines < 3 || numberOfLines > 5) {
      throw new InvalidNumberOfPulseException();
    }

    this.numberOfLines = numberOfLines;
    lines = new Line[numberOfLines];
    scaleY = new float[numberOfLines];
  }

  @Override public void initializeObjects() {
    lineWidth = width / (2 * numberOfLines);
    lineDistance = lineWidth / 4f;
    float firstX = (width - (lineWidth * numberOfLines + lineDistance * (numberOfLines - 1))) / 2f + lineWidth / 2f;
    for (int i = 0; i < numberOfLines; i++) {
      lines[i] = new Line();
      lines[i].setColor(color);
      lines[i].setWidth(lineWidth);
      lines[i].setPoint1(new PointF(firstX, center.y - height / 4f));
      lines[i].setPoint2(new PointF(firstX, center.y + height / 4f));
    }
  }

  @Override public void setUpAnimation() {
    for (int i = 0; i < numberOfLines; i++) {
      final int index = i;
      ValueAnimator scaleAnimator = ValueAnimator.ofFloat(1f, 1.5f, 1f);
      scaleAnimator.setDuration(1000);
      scaleAnimator.setStartDelay(i * 120);
      scaleAnimator.setRepeatCount(ValueAnimator.INFINITE);
      scaleAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override public void onAnimationUpdate(ValueAnimator animation) {
          scaleY[index] = (float)animation.getAnimatedValue();
          if (invalidateListener != null) {
            invalidateListener.reDraw();
          }
        }
      });

      scaleAnimator.start();
    }
  }

  @Override public void draw(Canvas canvas) {
    for (int i = 0; i < numberOfLines; i++) {
      canvas.save();
      canvas.translate(i * (lineWidth + lineDistance), 0);
      canvas.scale(1, scaleY[i], lines[i].getPoint1().x, center.y);
      lines[i].draw(canvas);
      canvas.restore();
    }
  }
}


public class Radar extends LoaderView {
  private Line line;
  private float degree;

  @Override public void initializeObjects() {
    final float size = Math.min(width, height);
    line = new Line();
    line.setPoint1(center);
    line.setPoint2(new PointF(0, size / 2f));
    line.setColor(color);
    line.setWidth(5);
  }

  @Override public void setUpAnimation() {
    ValueAnimator animator = ValueAnimator.ofFloat(0, 359);
    animator.setDuration(1000);
    animator.setRepeatCount(ValueAnimator.INFINITE);
    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
      @Override public void onAnimationUpdate(ValueAnimator animation) {
        degree = (float)animation.getAnimatedValue();
        if (invalidateListener != null) {
          invalidateListener.reDraw();
        }
      }
    });

    animator.start();
  }

  @Override public void draw(Canvas canvas) {
    canvas.save();
    canvas.rotate(degree, center.x, center.y);
    line.draw(canvas);
    canvas.restore();
  }
}


public class Sharingan extends LoaderView {
  private Circle eye;
  private Circle eyeBound;
  private Circle[] sharingans;
  private int numberOfSharingan;
  private float rotate;
  private float scale;
  private float eyeBoundRadius;
  private float eyeBoundRadiusScale;

  public Sharingan() {
    numberOfSharingan = 3;
  }

  @Override public void initializeObjects() {
    float r = Math.min(width, height) / 2f;
    eyeBoundRadius = r / 1.5f;

    eye = new Circle();
    eye.setCenter(center.x, center.y);
    eye.setColor(color);
    eye.setRadius(r / 4);

    eyeBound = new Circle();
    eyeBound.setCenter(center.x, center.y);
    eyeBound.setColor(color);
    eyeBound.setRadius(eyeBoundRadius);
    eyeBound.setStyle(Paint.Style.STROKE);
    eyeBound.setWidth(r / 20f);

    sharingans = new Circle[numberOfSharingan];
    for (int i = 0; i < numberOfSharingan; i++) {
      sharingans[i] = new Circle();
      sharingans[i].setCenter(center.x, center.y - eyeBoundRadius);
      sharingans[i].setColor(color);
      sharingans[i].setRadius(r / 6);
    }
  }

  @Override public void setUpAnimation() {
    ValueAnimator rotateAnimator = ValueAnimator.ofFloat(0, 360);
    rotateAnimator.setDuration(1500);
    rotateAnimator.setRepeatCount(ValueAnimator.INFINITE);
    rotateAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
      @Override public void onAnimationUpdate(ValueAnimator animation) {
        rotate = (float)animation.getAnimatedValue();
        if (invalidateListener != null) {
          invalidateListener.reDraw();
        }
      }
    });

    ValueAnimator scaleAnimator = ValueAnimator.ofFloat(1f, 0.8f, 1f);
    scaleAnimator.setDuration(1000);
    scaleAnimator.setRepeatCount(ValueAnimator.INFINITE);
    scaleAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
      @Override public void onAnimationUpdate(ValueAnimator animation) {
        scale = (float)animation.getAnimatedValue();
        if (invalidateListener != null) {
          invalidateListener.reDraw();
        }
      }
    });

    AnimatorSet animatorSet = new AnimatorSet();
    animatorSet.play(rotateAnimator).with(scaleAnimator);
    animatorSet.start();
  }

  @Override public void draw(Canvas canvas) {
    canvas.save();
    canvas.scale(scale, scale, center.x, center.y);
    canvas.rotate(rotate, center.x, center.y);
    eye.draw(canvas);
    eyeBound.draw(canvas);
    for (int i = 0; i < numberOfSharingan; i++) {
      canvas.save();
      canvas.rotate(i * 120, center.x, center.y);
      sharingans[i].draw(canvas);
      canvas.restore();
    }
    canvas.restore();
  }
}


public class TwinFishesSpinner extends LoaderView {
  private Circle[] circles;
  private int numberOfCircle;
  private float[] rotates;

  public TwinFishesSpinner() {
    numberOfCircle = 10;
    rotates = new float[numberOfCircle];
  }

  @Override public void initializeObjects() {
    final float size = Math.min(width, height);
    final float circleRadius = size / 10.0f;
    circles = new Circle[numberOfCircle];

    for (int i = 0; i < numberOfCircle / 2; i++) {
      circles[i] = new Circle();
      circles[i].setCenter(center.x, circleRadius);
      circles[i].setColor(color);
      circles[i].setRadius(circleRadius - circleRadius * i / 6);
    }

    for (int i = numberOfCircle / 2; i < numberOfCircle; i++) {
      circles[i] = new Circle();
      circles[i].setCenter(center.x, size - circleRadius);
      circles[i].setColor(color);
      circles[i].setRadius(circleRadius - circleRadius * (i - 5) / 6);
    }
  }

  @Override public void setUpAnimation() {
    for (int i = 0; i < numberOfCircle; i++) {
      final int index = i;

      ValueAnimator fadeAnimator = ValueAnimator.ofFloat(0, 360);
      fadeAnimator.setRepeatCount(ValueAnimator.INFINITE);
      fadeAnimator.setDuration(1700);
      fadeAnimator.setStartDelay((index >= 5 ? index - 5 : index) * 100);
      fadeAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override public void onAnimationUpdate(ValueAnimator animation) {
          rotates[index] = (float)animation.getAnimatedValue();
          if (invalidateListener != null) {
            invalidateListener.reDraw();
          }
        }
      });

      fadeAnimator.start();
    }
  }

  @Override public void draw(Canvas canvas) {
    for (int i = 0; i < numberOfCircle; i++) {
      canvas.save();
      canvas.rotate(rotates[i], center.x, center.y);
      circles[i].draw(canvas);
      canvas.restore();
    }
  }
}


public class Whirlpool extends LoaderView {
  private Arc[] arcs;
  private int numberOfArc;
  private float[] rotates;

  public Whirlpool() {
    numberOfArc = 3;
  }

  @Override public void initializeObjects() {
    float r = Math.min(width, height) / 2f;
    arcs = new Arc[numberOfArc];
    rotates = new float[numberOfArc];

    for (int i = 0; i < numberOfArc; i++) {
      float d = r / 4 + i * r / 4;
      arcs[i] = new Arc();
      arcs[i].setColor(color);
      arcs[i].setOval(new RectF(center.x - d, center.y - d, center.x + d, center.y + d));
      arcs[i].setStartAngle(i * 45);
      arcs[i].setSweepAngle(i * 45 + 90);
      arcs[i].setStyle(Paint.Style.STROKE);
      arcs[i].setWidth(r / 10f);
    }
  }

  @Override public void setUpAnimation() {
    for (int i = numberOfArc - 1; i >= 0; i--) {
      final int index = i;

      ValueAnimator fadeAnimator = ValueAnimator.ofFloat(arcs[i].getStartAngle(),
          arcs[i].getStartAngle() + 360* (i % 2 == 0 ? -1 : 1));
      fadeAnimator.setRepeatCount(ValueAnimator.INFINITE);
      fadeAnimator.setDuration((i + 1) * 500);
      fadeAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override public void onAnimationUpdate(ValueAnimator animation) {
          rotates[index] = (float)animation.getAnimatedValue();
          if (invalidateListener != null) {
            invalidateListener.reDraw();
          }
        }
      });

      fadeAnimator.start();
    }
  }

  @Override public void draw(Canvas canvas) {
    for (int i = 0; i < numberOfArc; i++) {
      canvas.save();
      canvas.rotate(rotates[i], center.x, center.y);
      arcs[i].draw(canvas);
      canvas.restore();
    }
  }
}



public class Worm extends LoaderView {
  private Circle[] circles;
  private int circlesSize;
  private float radius;
  private int[] transformations;

  public Worm() {
    circlesSize = 5;
    transformations = new int[]{-2, -1, 0, 1, 2};
  }

  @Override public void initializeObjects() {
    circles = new Circle[circlesSize];
    radius = width / 10f - width / 100f;

    for (int i = 0; i < circlesSize; i++) {
      circles[i] = new Circle();
      circles[i].setColor(color);
      circles[i].setRadius(radius);
      circles[i].setCenter(center.x, center.y);
    }
  }

  @Override public void setUpAnimation() {
    for (int i = 0; i < circlesSize; i++) {
      final int index = i;
      ValueAnimator translateAnimator = ValueAnimator.ofFloat(center.y, height / 4f, height * 3 / 4f, center.y);
      translateAnimator.setDuration(1000);
      translateAnimator.setStartDelay(index * 120);
      translateAnimator.setRepeatCount(ValueAnimator.INFINITE);
      translateAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override public void onAnimationUpdate(ValueAnimator animation) {
          circles[index].setCenter(center.x, (float)animation.getAnimatedValue());
          if (invalidateListener != null) {
            invalidateListener.reDraw();
          }
        }
      });

      translateAnimator.start();
    }
  }

  @Override public void draw(Canvas canvas) {
    for (int i = 0; i < circlesSize; i++) {
      canvas.save();
      canvas.translate(2 * radius * transformations[i], 0);
      circles[i].draw(canvas);
      canvas.restore();
    }
  }
}



public abstract class LoaderView {
  protected int color;
  protected int width, height;
  protected int desiredWidth, desiredHeight;
  protected PointF center;
  protected InvalidateListener invalidateListener;

  public LoaderView() {
    this.desiredWidth = 150;
    this.desiredHeight = 150;
  }

  public void setColor(int color) {
    this.color = color;
  }

  public void setSize(int width, int height) {
    this.width = width;
    this.height = height;
    this.center = new PointF(width / 2.0f, height / 2.0f);
  }

  public void setInvalidateListener(InvalidateListener invalidateListener) {
    this.invalidateListener = invalidateListener;
  }

  public int getDesiredWidth() {
    return desiredWidth;
  }

  public int getDesiredHeight() {
    return desiredHeight;
  }

  public abstract void initializeObjects();

  public abstract void setUpAnimation();

  public abstract void draw(Canvas canvas);

  public boolean isDetached() {
    return invalidateListener == null;
  }

  public void onDetach() {
    if (invalidateListener != null) {
      invalidateListener = null;
    }
  }
}


public static class LoaderGenerator {
  public static LoaderView generateLoaderView(int type) {
    MainActivity aan = new MainActivity();
    switch (type) {
      case 0:
        return aan.new ClassicSpinner();
      case 1:
        return aan.new FishSpinner();
      case 2:
        return aan.new LineSpinner();
      case 3:
        try {
          return aan.new Pulse(3);
        } catch (InvalidNumberOfPulseException e) {
          e.printStackTrace();
        }
      case 4:
        try {
          return aan.new Pulse(4);
        } catch (InvalidNumberOfPulseException e) {
          e.printStackTrace();
        }
      case 5:
        try {
          return aan.new Pulse(5);
        } catch (InvalidNumberOfPulseException e) {
          e.printStackTrace();
        }
      case 6:
        return aan.new Radar();
      case 7:
        return aan.new TwinFishesSpinner();
      case 8:
        return aan.new Worm();
      case 9:
        return aan.new Whirlpool();
      case 10:
        return aan.new PhoneWave();
      case 11:
        return aan.new Sharingan();
      default:
        return aan.new ClassicSpinner();
    }
  }

  public static LoaderView generateLoaderView(String type) {
    MainActivity aan = new MainActivity();
    switch (type) {
      case "ClassicSpinner":
        return aan.new ClassicSpinner();
      case "FishSpinner":
        return aan.new FishSpinner();
      case "LineSpinner":
        return aan.new LineSpinner();
      case "ThreePulse":
        try {
          return aan.new Pulse(3);
        } catch (InvalidNumberOfPulseException e) {
          e.printStackTrace();
        }
      case "FourPulse":
        try {
          return aan.new Pulse(4);
        } catch (InvalidNumberOfPulseException e) {
          e.printStackTrace();
        }
      case "FivePulse":
        try {
          return aan.new Pulse(5);
        } catch (InvalidNumberOfPulseException e) {
          e.printStackTrace();
        }
      case "Radar":
        return aan.new Radar();
      case "TwinFishesSpinner":
        return aan.new TwinFishesSpinner();
      case "Worm":
        return aan.new Worm();
      case "Whirlpool":
        return aan.new Whirlpool();
      case "PhoneWave":
        return aan.new PhoneWave();
      case "Sharingan":
        return aan.new Sharingan();
      default:
        return aan.new ClassicSpinner();
    }
  }
}


public class MKLoader extends View implements InvalidateListener {
  private int setLoaderType;
  private String setLoaderColor;
  private LoaderView loaderView;

  public MKLoader(Context context) {
    super(context);
    initialize(context, null, 0);
  }

  public MKLoader(Context context, AttributeSet attrs) {
    super(context, attrs);
    initialize(context, attrs, 0);
  }

  public MKLoader(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    initialize(context, attrs, defStyleAttr);
  }

  private void initialize(Context context, AttributeSet attrs, int defStyleAttr) {
    //TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MKLoader);
    //int loaderType = typedArray.getInt(R.styleable.MKLoader_mk_type,-1);
    //int loaderType = -1;
    //loaderView = LoaderGenerator.generateLoaderView(setLoaderType);
    //loaderView.setColor(Color.parseColor("#ffffff"));
    //loaderView.setColor(typedArray.getColor(R.styleable.MKLoader_mk_color, Color.parseColor("#ffffff")));
    //typedArray.recycle();
  }

  public void setType(int _type) {
	 this.setLoaderType = _type;
	 loaderView = LoaderGenerator.generateLoaderView(setLoaderType);
  }
  public void setColor(String _color) {
  	this.setLoaderColor = _color;
      loaderView.setColor(Color.parseColor(setLoaderColor));
  }

  @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    final int measuredWidth = resolveSize(loaderView.getDesiredWidth(), widthMeasureSpec);
    final int measuredHeight = resolveSize(loaderView.getDesiredHeight(), heightMeasureSpec);

    setMeasuredDimension(measuredWidth, measuredHeight);
  }

  @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    super.onLayout(changed, left, top, right, bottom);
    loaderView.setSize(getWidth(), getHeight());
    loaderView.initializeObjects();
    loaderView.setUpAnimation();
  }

  @Override protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    loaderView.draw(canvas);
  }

  @Override public void reDraw() {
    invalidate();
  }

  @Override protected void onAttachedToWindow() {
    super.onAttachedToWindow();
    if (loaderView != null && loaderView.isDetached()) {
      loaderView.setInvalidateListener(this);
    }
  }

  @Override protected void onDetachedFromWindow() {
    super.onDetachedFromWindow();
    if (loaderView != null) {
      loaderView.onDetach();
    }
  }
}



//EXAMPLE USED
final MKLoader a = new MKLoader(this);

a.setLayoutParams(new LinearLayout.LayoutParams(android.widget.LinearLayout.LayoutParams.WRAP_CONTENT, android.widget.LinearLayout.LayoutParams.WRAP_CONTENT));

a.setType(2); //0-11

a.setColor("#FFFFFF");

linear1.addView(a);



## Supported Types
- Sharingan
- TwinFishesSpinner
- ClassicSpinner
- LineSpinner
- FishSpinner
- PhoneWave
- ThreePulse
- FourPulse
- FivePulse
- Worm
- Whirlpool
- Radar

## From Int Type
0 = ClassicSpinner
1 = FishSpinner
2 = LineSpinner
3 = Pulse(3)
4 = Pulse(4)
5 = Pulse(5)
6 = Radar
7 = TwinFishesSpinner
8 = Worm
9 = Whirlpool
10 = PhoneWave
11 = Sharingan

## By Default
ClassicSpinner


}


public class Titanic {

    private AnimatorSet animatorSet;
    private Animator.AnimatorListener animatorListener;

    public Animator.AnimatorListener getAnimatorListener() {
        return animatorListener;
    }

    public void setAnimatorListener(Animator.AnimatorListener animatorListener) {
        this.animatorListener = animatorListener;
    }

    public void start(final TitanicTextView textView) {

        final Runnable animate = new Runnable() {
            @Override
            public void run() {

                textView.setSinking(true);

                // horizontal animation. 200 = wave.png width
                ObjectAnimator maskXAnimator = ObjectAnimator.ofFloat(textView, "maskX", 0, 200);
                maskXAnimator.setRepeatCount(ValueAnimator.INFINITE);
                maskXAnimator.setDuration(1000);
                maskXAnimator.setStartDelay(0);

                int h = textView.getHeight();

                // vertical animation
                // maskY = 0 -> wave vertically centered
                // repeat mode REVERSE to go back and forth
                ObjectAnimator maskYAnimator = ObjectAnimator.ofFloat(textView, "maskY", h/2, - h/2);
                maskYAnimator.setRepeatCount(ValueAnimator.INFINITE);
                maskYAnimator.setRepeatMode(ValueAnimator.REVERSE);
                maskYAnimator.setDuration(10000);
                maskYAnimator.setStartDelay(0);

                // now play both animations together
                animatorSet = new AnimatorSet();
                animatorSet.playTogether(maskXAnimator, maskYAnimator);
                animatorSet.setInterpolator(new LinearInterpolator());
                animatorSet.addListener(new Animator.AnimatorListener() {
                    @Override
                    public void onAnimationStart(Animator animation) {
                    }

                    @Override
                    public void onAnimationEnd(Animator animation) {
                        textView.setSinking(false);

                        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {
                            textView.postInvalidate();
                        } else {
                            textView.postInvalidateOnAnimation();
                        }

                        animatorSet = null;
                    }

                    @Override
                    public void onAnimationCancel(Animator animation) {

                    }

                    @Override
                    public void onAnimationRepeat(Animator animation) {

                    }
                });


                if (animatorListener != null) {
                    animatorSet.addListener(animatorListener);
                }

                animatorSet.start();
            }
        };

        if (!textView.isSetUp()) {
            textView.setAnimationSetupCallback(new AnimationSetupCallback() {
                @Override
                public void onSetupAnimation(final TitanicTextView target) {
                    animate.run();
                }
            });
        } else {
            animate.run();
        }
    }

    public void cancel() {
        if (animatorSet != null) {
            animatorSet.cancel();
        }
    }
}


public interface AnimationSetupCallback {
        public void onSetupAnimation(TitanicTextView titanicTextView);
    }


public class TitanicTextView extends TextView {
    // callback fired at first onSizeChanged
    private AnimationSetupCallback animationSetupCallback;
    // wave shader coordinates
    private float maskX, maskY;
    // if true, the shader will display the wave
    private boolean sinking;
    // true after the first onSizeChanged
    private boolean setUp;

    // shader containing a repeated wave
    private BitmapShader shader;
    // shader matrix
    private Matrix shaderMatrix;
    // wave drawable
    private android.graphics.drawable.Drawable wave;
    // (getHeight() - waveHeight) / 2
    private float offsetY;

    public TitanicTextView(Context context) {
        super(context);
        init();
    }

    public TitanicTextView(Context context, AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    public TitanicTextView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        init();
    }

    private void init() {
        shaderMatrix = new Matrix();
    }

    public AnimationSetupCallback getAnimationSetupCallback() {
        return animationSetupCallback;
    }

    public void setAnimationSetupCallback(AnimationSetupCallback animationSetupCallback) {
        this.animationSetupCallback = animationSetupCallback;
    }

    public float getMaskX() {
        return maskX;
    }

    public void setMaskX(float maskX) {
        this.maskX = maskX;
        invalidate();
    }

    public float getMaskY() {
        return maskY;
    }

    public void setMaskY(float maskY) {
        this.maskY = maskY;
        invalidate();
    }

    public boolean isSinking() {
        return sinking;
    }

    public void setSinking(boolean sinking) {
        this.sinking = sinking;
    }

    public boolean isSetUp() {
        return setUp;
    }

    @Override
    public void setTextColor(int color) {
        super.setTextColor(color);
        createShader();
    }

    @Override
    public void setTextColor(android.content.res.ColorStateList colors) {
        super.setTextColor(colors);
        createShader();
    }

    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);

        createShader();

        if (!setUp) {
            setUp = true;
            if (animationSetupCallback != null) {
                animationSetupCallback.onSetupAnimation(TitanicTextView.this);
            }
        }
    }

    /**
     * Create the shader
     * draw the wave with current color for a background
     * repeat the bitmap horizontally, and clamp colors vertically
     */
    @SuppressWarnings("deprecation")
    private void createShader() {

        if (wave == null) {
            wave = getResources().getDrawable(R.drawable.wave);
        }

        int waveW = wave.getIntrinsicWidth();
        int waveH = wave.getIntrinsicHeight();

        Bitmap b = Bitmap.createBitmap(waveW, waveH, Bitmap.Config.ARGB_8888);
        Canvas c = new Canvas(b);

        c.drawColor(getCurrentTextColor());

        wave.setBounds(0, 0, waveW, waveH);
        wave.draw(c);

        shader = new BitmapShader(b, Shader.TileMode.REPEAT, Shader.TileMode.CLAMP);
        getPaint().setShader(shader);

        offsetY = (getHeight() - waveH) / 2;
 
    }

    @Override
    protected void onDraw(Canvas canvas) {

        // modify text paint shader according to sinking state
        if (sinking && shader != null) {

            // first call after sinking, assign it to our paint
            if (getPaint().getShader() == null) {
                getPaint().setShader(shader);
            }

            // translate shader accordingly to maskX maskY positions
            // maskY is affected by the offset to vertically center the wave
            shaderMatrix.setTranslate(maskX, maskY + offsetY);

            // assign matrix to invalidate the shader
            shader.setLocalMatrix(shaderMatrix);
        } else {
            getPaint().setShader(null);
        }

        super.onDraw(canvas);
    }
}

public void nothing() {
	

public static class DilatingDotDrawable extends android.graphics.drawable.Drawable {
    private static final String TAG = DilatingDotDrawable.class.getSimpleName();
    private Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
    private float radius;
    private float maxRadius;
    final Rect mDirtyBounds = new Rect(0, 0, 0, 0);

    public DilatingDotDrawable(final int color, final float radius, final float maxRadius) {
        mPaint.setColor(color);
        mPaint.setStyle(Paint.Style.FILL);
        mPaint.setStrokeCap(Paint.Cap.ROUND);
        mPaint.setStrokeJoin(Paint.Join.ROUND);

        this.radius = radius;
        setMaxRadius(maxRadius);
    }

    @Override
    public void draw(Canvas canvas) {
        final Rect bounds = getBounds();
        canvas.drawCircle(bounds.centerX(), bounds.centerY(), radius - 1, mPaint);
    }

    @Override
    public void setAlpha(int alpha) {
        if (alpha != mPaint.getAlpha()) {
            mPaint.setAlpha(alpha);
            invalidateSelf();
        }
    }

    @Override
    public void setColorFilter(ColorFilter colorFilter) {
        mPaint.setColorFilter(colorFilter);
        invalidateSelf();
    }

    @Override
    public int getOpacity() {
        return PixelFormat.TRANSLUCENT;
    }

    public void setColor(int color) {
        mPaint.setColor(color);
        invalidateSelf();
    }

    public void setRadius(float radius) {
        this.radius = radius;
        invalidateSelf();
    }

    public float getRadius() {
        return radius;
    }

    @Override
    public int getIntrinsicWidth() {
        return (int) (maxRadius * 2) + 2;
    }

    @Override
    public int getIntrinsicHeight() {
        return (int) (maxRadius * 2) + 2;
    }

    public void setMaxRadius(final float maxRadius) {
        this.maxRadius = maxRadius;
        mDirtyBounds.bottom = (int) (maxRadius * 2) + 2;
        mDirtyBounds.right = (int) (maxRadius * 2) + 2;
    }

    @Override
    public Rect getDirtyBounds() {
        return mDirtyBounds;
    }

    @Override
    protected void onBoundsChange(final Rect bounds) {
        super.onBoundsChange(bounds);
        mDirtyBounds.offsetTo(bounds.left, bounds.top);
    }
}


public static class DilatingDotsProgressBar extends View {
    public static final String TAG = DilatingDotsProgressBar.class.getSimpleName();
    public static final double START_DELAY_FACTOR = 0.35;
    private static final float DEFAULT_GROWTH_MULTIPLIER = 1.75f;
    private static final int MIN_SHOW_TIME = 500; // ms
    private static final int MIN_DELAY = 500; // ms
    private int mDotColor;
    private int mDotEndColor;
    private int mAnimationDuration;
    private int mWidthBetweenDotCenters;
    private int mNumberDots;
    private float mDotRadius;
    private float mDotScaleMultiplier;
    private float mDotMaxRadius;
    private float mHorizontalSpacing;
    private long mStartTime = -1;
    private boolean mShouldAnimate;
    private boolean mDismissed = false;
    private boolean mIsRunning = false;
    private boolean mAnimateColors = false;
    private ArrayList<DilatingDotDrawable> mDrawables = new ArrayList<>();
    private final List<android.animation.Animator> mAnimations = new ArrayList<>();
    /** delayed runnable to stop the progress */
    private final Runnable mDelayedHide = new Runnable() {
        @Override
        public void run() {
            mStartTime = -1;
            mIsRunning = false;
            setVisibility(View.GONE);
            stopAnimations();
        }
    };

    /** delayed runnable to start the progress */
    private final Runnable mDelayedShow = new Runnable() {
        @Override
        public void run() {
            if (!mDismissed) {
                mStartTime = System.currentTimeMillis();
                setVisibility(View.VISIBLE);
                startAnimations();
            }
        }
    };

    public DilatingDotsProgressBar(Context context) {
        this(context, null);
    }

    public DilatingDotsProgressBar(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public DilatingDotsProgressBar(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init(attrs);
    }

    private void init(AttributeSet attrs) {
        //TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.DilatingDotsProgressBar);
        //mNumberDots = a.getInt(R.styleable.DilatingDotsProgressBar_dd_numDots, 3);
        //mDotRadius = a.getDimension(R.styleable.DilatingDotsProgressBar_android_radius, 8);
        //mDotColor = a.getColor(R.styleable.DilatingDotsProgressBar_android_color, 0xff9c27b0);
        //mDotEndColor = a.getColor(R.styleable.DilatingDotsProgressBar_dd_endColor, mDotColor);
        //mDotScaleMultiplier = a.getFloat(R.styleable.DilatingDotsProgressBar_dd_scaleMultiplier, DEFAULT_GROWTH_MULTIPLIER);
        //mAnimationDuration = a.getInt(R.styleable.DilatingDotsProgressBar_dd_animationDuration, 300);
        //mHorizontalSpacing = a.getDimension(R.styleable.DilatingDotsProgressBar_dd_horizontalSpacing, 12);
        //a.recycle();


        mNumberDots = 3;
        mDotRadius = 8;
        mDotColor = Color.RED;
        mDotEndColor = mDotColor;
        mDotScaleMultiplier = DEFAULT_GROWTH_MULTIPLIER;
        mAnimationDuration = 300;
        mHorizontalSpacing = 12;



        mShouldAnimate = false;
        mAnimateColors = mDotColor != mDotEndColor;
        calculateMaxRadius();
        calculateWidthBetweenDotCenters();

        initDots();
        updateDots();
    }

    @Override
    protected void onSizeChanged(final int w, final int h, final int oldw, final int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);
        if (computeMaxHeight() != h || w != computeMaxWidth()) {
            updateDots();
        }
    }

    @Override
    public void onDetachedFromWindow() {
        super.onDetachedFromWindow();
        removeCallbacks();
    }

    private void removeCallbacks() {
        removeCallbacks(mDelayedHide);
        removeCallbacks(mDelayedShow);
    }

    public void reset() {
        hideNow();
    }

    /**
     * Hide the progress view if it is visible. The progress view will not be
     * hidden until it has been shown for at least a minimum show time. If the
     * progress view was not yet visible, cancels showing the progress view.
     */
    @SuppressWarnings ("unused")
    public void hide() {
        hide(MIN_SHOW_TIME);
    }

    public void hide(int delay) {
        mDismissed = true;
        removeCallbacks(mDelayedShow);
        long diff = System.currentTimeMillis() - mStartTime;
        if ((diff >= delay) || (mStartTime == -1)) {
            mDelayedHide.run();
        } else {
            if ((delay - diff) <= 0) {
                mDelayedHide.run();
            } else {
                postDelayed(mDelayedHide, delay - diff);
            }
        }
    }

    /**
     * Show the progress view after waiting for a minimum delay. If
     * during that time, hide() is called, the view is never made visible.
     */
    @SuppressWarnings ("unused")
    public void show() {
        show(MIN_DELAY);
    }

    @SuppressWarnings ("unused")
    public void showNow() {
        show(0);
    }

    @SuppressWarnings ("unused")
    public void hideNow() {
        hide(0);
    }

    public void show(int delay) {
        if (mIsRunning) {
            return;
        }

        mIsRunning = true;

        mStartTime = -1;
        mDismissed = false;
        removeCallbacks(mDelayedHide);

        if (delay == 0) {
            mDelayedShow.run();
        } else {
            postDelayed(mDelayedShow, delay);
        }
    }

    @Override
    protected void onDraw(Canvas canvas) {
        if (shouldAnimate()) {
            for (DilatingDotDrawable dot : mDrawables) {
                dot.draw(canvas);
            }
        }
    }

    @Override
    protected boolean verifyDrawable(final android.graphics.drawable.Drawable who) {
        if (shouldAnimate()) {
            return mDrawables.contains(who);
        }
        return super.verifyDrawable(who);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        setMeasuredDimension((int) computeMaxWidth(), (int) computeMaxHeight());
    }

    private float computeMaxHeight() {
        return mDotMaxRadius * 2;
    }

    private float computeMaxWidth() {
        return computeWidth() + ((mDotMaxRadius - mDotRadius) * 2);
    }

    private float computeWidth() {
        return (((mDotRadius * 2) + mHorizontalSpacing) * mDrawables.size()) - mHorizontalSpacing;
    }

    private void calculateMaxRadius() {
        mDotMaxRadius = mDotRadius * mDotScaleMultiplier;
    }

    private void calculateWidthBetweenDotCenters() {
        mWidthBetweenDotCenters = (int) (mDotRadius * 2) + (int) mHorizontalSpacing;
    }

    private void initDots() {
        mDrawables.clear();
        mAnimations.clear();
        for (int i = 1; i <= mNumberDots; i++) {
            final DilatingDotDrawable dot = new DilatingDotDrawable(mDotColor, mDotRadius, mDotMaxRadius);
            dot.setCallback(this);
            mDrawables.add(dot);

            final long startDelay = (i - 1) * (int) (START_DELAY_FACTOR * mAnimationDuration);

            // Sizing
            android.animation.ValueAnimator growAnimator = android.animation.ObjectAnimator.ofFloat(dot, "radius", mDotRadius, mDotMaxRadius, mDotRadius);
            growAnimator.setDuration(mAnimationDuration);
            growAnimator.setInterpolator(new android.view.animation.AccelerateDecelerateInterpolator());
            if (i == mNumberDots) {
                growAnimator.addListener(new android.animation.AnimatorListenerAdapter() {
                    @Override
                    public void onAnimationEnd(android.animation.Animator animation) {
                        if (shouldAnimate()) {
                            startAnimations();
                        }
                    }
                });
            }
            growAnimator.setStartDelay(startDelay);

            mAnimations.add(growAnimator);

            if (mAnimateColors) {
                // Gradient
                android.animation.ValueAnimator colorAnimator = android.animation.ValueAnimator.ofInt(mDotEndColor, mDotColor);
                colorAnimator.setDuration(mAnimationDuration);
                colorAnimator.setEvaluator(new android.animation.ArgbEvaluator());
                colorAnimator.addUpdateListener(new android.animation.ValueAnimator.AnimatorUpdateListener() {

                    @Override
                    public void onAnimationUpdate(android.animation.ValueAnimator animator) {
                        dot.setColor((int) animator.getAnimatedValue());
                    }

                });
                if (i == mNumberDots) {
                    colorAnimator.addListener(new android.animation.AnimatorListenerAdapter() {
                        @Override
                        public void onAnimationEnd(android.animation.Animator animation) {
                            if (shouldAnimate()) {
                                startAnimations();
                            }
                        }
                    });
                }
                colorAnimator.setStartDelay(startDelay);

                mAnimations.add(colorAnimator);
            }
        }
    }

    private void updateDots() {
        if (mDotRadius <= 0) {
            mDotRadius = getHeight() / 2 / mDotScaleMultiplier;
        }

        int left = (int) (mDotMaxRadius - mDotRadius);
        int right = (int) (left + mDotRadius * 2) + 2;
        int top = 0;
        int bottom = (int) (mDotMaxRadius * 2) + 2;

        for (int i = 0; i < mDrawables.size(); i++) {
            final DilatingDotDrawable dot = mDrawables.get(i);
            dot.setRadius(mDotRadius);
            dot.setBounds(left, top, right, bottom);
            android.animation.ValueAnimator growAnimator = (android.animation.ValueAnimator) mAnimations.get(i);
            growAnimator.setFloatValues(mDotRadius, mDotRadius * mDotScaleMultiplier, mDotRadius);

            left += mWidthBetweenDotCenters;
            right += mWidthBetweenDotCenters;
        }
    }

    protected void startAnimations() {
        mShouldAnimate = true;
        for (android.animation.Animator anim : mAnimations) {
            anim.start();
        }
    }

    protected void stopAnimations() {
        mShouldAnimate = false;
        removeCallbacks();
        for (android.animation.Animator anim : mAnimations) {
            anim.cancel();
        }
    }

    protected boolean shouldAnimate() {
        return mShouldAnimate;
    }

    // -------------------------------
    // ------ Getters & Setters ------
    // -------------------------------

    public void setDotRadius(float radius) {
        reset();
        mDotRadius = radius;
        calculateMaxRadius();
        calculateWidthBetweenDotCenters();
        setupDots();
    }

    public void setDotSpacing(float horizontalSpacing) {
        reset();
        mHorizontalSpacing = horizontalSpacing;
        calculateWidthBetweenDotCenters();
        setupDots();
    }

    public void setGrowthSpeed(int growthSpeed) {
        reset();
        mAnimationDuration = growthSpeed;
        setupDots();
    }

    public void setNumberOfDots(int numDots) {
        reset();
        mNumberDots = numDots;
        setupDots();
    }

    public void setDotScaleMultiplier(float multiplier) {
        reset();
        mDotScaleMultiplier = multiplier;
        calculateMaxRadius();
        setupDots();
    }

    public void setDotColor(int color) {
        if (color != mDotColor) {
            if (mAnimateColors) {
                // Cancel previous animations
                reset();
                mDotColor = color;
                mDotEndColor = color;
                mAnimateColors = false;

                setupDots();

            } else {
                mDotColor = color;
                for (DilatingDotDrawable dot : mDrawables) {
                    dot.setColor(mDotColor);
                }
            }
        }
    }

    /**
     * Set different start and end colors for dots. This will result in gradient behaviour. In case you want set 1 solid
     * color - use {@link #setDotColor(int)} instead
     *
     * @param startColor starting color of the dot
     * @param endColor   ending color of the dot
     */
    public void setDotColors(int startColor, int endColor) {
        if (mDotColor != startColor || mDotEndColor != endColor) {
            if (mAnimateColors) {
                reset();
            }
            mDotColor = startColor;
            mDotEndColor = endColor;

            mAnimateColors = mDotColor != mDotEndColor;

            setupDots();
        }
    }

    private void setupDots() {
        initDots();
        updateDots();
        showNow();
    }

    public int getDotGrowthSpeed() {
        return mAnimationDuration;
    }

    public float getDotRadius() {
        return mDotRadius;
    }

    public float getHorizontalSpacing() {
        return mHorizontalSpacing;
    }

    public int getNumberOfDots() {
        return mNumberDots;
    }

    public float getDotScaleMultiplier() {
        return mDotScaleMultiplier;
    }
  
public static class TiltAnimation extends android.view.animation.Animation {

	private static final String TAG = "com.java.library";

	public static final int ROTATE_AXIS_X = 0;
	public static final int ROTATE_AXIS_Y = 1;

	private final float mCenterX;
	private final float mCenterY;

	private Camera mCamera;

	private final ArrayList<Rotation> mRotations = new ArrayList<Rotation>();

	public TiltAnimation(float fromDegrees, float toDegrees, float centerX, float centerY, int rotateAxe) {
		this(centerX, centerY);
		mRotations.add(new Rotation(rotateAxe, fromDegrees, toDegrees));
	}

	public TiltAnimation(float centerX, float centerY) {
		mCenterX = centerX;
		mCenterY = centerY;
	}

	public void addRotation(float fromDegrees, float toDegrees, int rotateAxe) {
		mRotations.add(new Rotation(rotateAxe, fromDegrees, toDegrees));
	}

	@Override
	public void initialize(int width, int height, int parentWidth, int parentHeight) {
		super.initialize(width, height, parentWidth, parentHeight);
		mCamera = new Camera();
	}

	@Override
	protected void applyTransformation(float interpolatedTime, android.view.animation.Transformation t) {
		final float centerX = mCenterX;
		final float centerY = mCenterY;

		final Matrix matrix = t.getMatrix();

		mCamera.save();

		for(Rotation rotation : mRotations) {
			Log.d(TAG, "rotation : " + rotation);
			float degrees = rotation.mFromDegrees + ((rotation.mToDegrees - rotation.mFromDegrees) * interpolatedTime);
			if(rotation.mRotateAxis == ROTATE_AXIS_X) {
				mCamera.rotateX(degrees);
			} else if(rotation.mRotateAxis == ROTATE_AXIS_Y) {
				mCamera.rotateY(degrees);
			}
		}

		mCamera.getMatrix(matrix);
		mCamera.restore();

		matrix.preTranslate(-centerX, -centerY);
		matrix.postTranslate(centerX, centerY);

	}

	public void addRotations(Rotation... rotations) {
		mRotations.addAll(Arrays.asList(rotations));
	}


	public static final class Rotation {
		int mRotateAxis;
		float mFromDegrees;
		float mToDegrees;

		public Rotation(int mAxis, float mFromDegrees, float mToDegrees) {
			this.mRotateAxis = mAxis;
			this.mFromDegrees = mFromDegrees;
			this.mToDegrees = mToDegrees;
		}

		@Override
		public String toString() {
			return "Rotation{" +
					"mRotateAxis=" + (mRotateAxis == ROTATE_AXIS_X ? "X":"Y") +
					", mFromDegrees=" + mFromDegrees +
					", mToDegrees=" + mToDegrees +
					'}';
		}
	}
}




public static class TiltEffectAttacher implements View.OnTouchListener {

	enum TouchPart {LEFT, RIGHT, BOTTOM, TOP, TOPLEFT, TOPRIGHT, BOTTOMLEFT, MIDDLE, BOTTOMRIGHT}

	private static final String TAG = "com.java.library";

	private static int TILT_VALUE = 5;

	private TouchPart mTouchPart = TouchPart.MIDDLE;

	private ArrayList<TiltAnimation.Rotation> mLastRotations = new ArrayList<TiltAnimation.Rotation>();

	private java.lang.ref.WeakReference<View> mView;

	public static final TiltEffectAttacher attach(View view) {
		return new TiltEffectAttacher(view);
	}

	private TiltEffectAttacher(View view) {
		this.mView = new java.lang.ref.WeakReference<View>(view);
		view.setOnTouchListener(this);
	}

	public final void cleanup() {
		this.mView = null;
	}

	@Override
	public boolean onTouch(View v, MotionEvent event) {
		final View view = mView.get();
		final int action = event.getAction();

		float x = event.getX();
		float y = event.getY();

		int height = view.getHeight();
		int width = view.getWidth();

		float cornerWidth = width * 0.20f;
		float cornerHeight = height * 0.20f;

		TouchPart oldTouchPart = mTouchPart;

		switch (action) {
			case MotionEvent.ACTION_UP:
				mTouchPart = TouchPart.MIDDLE;
				break;
			case MotionEvent.ACTION_DOWN:
			case MotionEvent.ACTION_MOVE:
				if(x <= cornerWidth && y <= cornerHeight) {
					mTouchPart = TouchPart.TOPLEFT;
				} else if(x <= cornerWidth && y >= height-cornerHeight) {
					mTouchPart = TouchPart.BOTTOMLEFT;
				} else if(x >= width-cornerWidth && y <= cornerHeight) {
					mTouchPart = TouchPart.TOPRIGHT;
				} else if(x >= width-cornerWidth && y >= height-cornerHeight) {
					mTouchPart = TouchPart.BOTTOMRIGHT;
				} else if(x > cornerWidth && x < width-cornerWidth && y <= cornerHeight) {
					mTouchPart = TouchPart.TOP;
				} else if(x > cornerWidth && x < width-cornerWidth && y >= height-cornerHeight) {
					mTouchPart = TouchPart.BOTTOM;
				} else if(y > cornerHeight && y < height-cornerHeight && x <= cornerWidth) {
					mTouchPart = TouchPart.LEFT;
				} else if(y > cornerHeight && y < height-cornerHeight && x >= width-cornerWidth) {
					mTouchPart = TouchPart.RIGHT;
				} else {
					mTouchPart = TouchPart.MIDDLE;
				}
				break;
		}

		if(mTouchPart != oldTouchPart) {
			Log.d(TAG, "TouchPart has changed : " + mTouchPart);
			switch (mTouchPart) {
				case MIDDLE:
					applyTitlEffect(view, buildResetRotations());
					break;
				case LEFT:
					applyTitlEffect(view, buildResetRotations(TiltAnimation.ROTATE_AXIS_Y), getLastToDegreesByAxis(TiltAnimation.ROTATE_AXIS_Y), -TILT_VALUE, TiltAnimation.ROTATE_AXIS_Y);
					break;
				case RIGHT:
					applyTitlEffect(view, buildResetRotations(TiltAnimation.ROTATE_AXIS_Y), getLastToDegreesByAxis(TiltAnimation.ROTATE_AXIS_Y), TILT_VALUE, TiltAnimation.ROTATE_AXIS_Y);
					break;
				case BOTTOM:
					applyTitlEffect(view, buildResetRotations(TiltAnimation.ROTATE_AXIS_X), getLastToDegreesByAxis(TiltAnimation.ROTATE_AXIS_X), -TILT_VALUE, TiltAnimation.ROTATE_AXIS_X);
					break;
				case TOP:
					applyTitlEffect(view, buildResetRotations(TiltAnimation.ROTATE_AXIS_X), getLastToDegreesByAxis(TiltAnimation.ROTATE_AXIS_X), TILT_VALUE, TiltAnimation.ROTATE_AXIS_X);
					break;
				case TOPLEFT:
					applyTitlEffect(view,
							new TiltAnimation.Rotation(TiltAnimation.ROTATE_AXIS_X, getLastToDegreesByAxis(TiltAnimation.ROTATE_AXIS_X), TILT_VALUE),
							new TiltAnimation.Rotation(TiltAnimation.ROTATE_AXIS_Y, getLastToDegreesByAxis(TiltAnimation.ROTATE_AXIS_Y), -TILT_VALUE));
					break;
				case TOPRIGHT:
					applyTitlEffect(view,
							new TiltAnimation.Rotation(TiltAnimation.ROTATE_AXIS_X, getLastToDegreesByAxis(TiltAnimation.ROTATE_AXIS_X), TILT_VALUE),
							new TiltAnimation.Rotation(TiltAnimation.ROTATE_AXIS_Y, getLastToDegreesByAxis(TiltAnimation.ROTATE_AXIS_Y), TILT_VALUE));
					break;
				case BOTTOMLEFT:
					applyTitlEffect(view,
							new TiltAnimation.Rotation(TiltAnimation.ROTATE_AXIS_X, getLastToDegreesByAxis(TiltAnimation.ROTATE_AXIS_X), -TILT_VALUE),
							new TiltAnimation.Rotation(TiltAnimation.ROTATE_AXIS_Y, getLastToDegreesByAxis(TiltAnimation.ROTATE_AXIS_Y), -TILT_VALUE));
					break;
				case BOTTOMRIGHT:
					applyTitlEffect(view,
							new TiltAnimation.Rotation(TiltAnimation.ROTATE_AXIS_X, getLastToDegreesByAxis(TiltAnimation.ROTATE_AXIS_X), -TILT_VALUE),
							new TiltAnimation.Rotation(TiltAnimation.ROTATE_AXIS_Y, getLastToDegreesByAxis(TiltAnimation.ROTATE_AXIS_Y), TILT_VALUE));
					break;
			}
		}

		return false;
	}

	private TiltAnimation.Rotation[] buildResetRotations(int... exceptAxises) {
		if(mLastRotations == null || mLastRotations.isEmpty()) {
			return new TiltAnimation.Rotation[0];
		}
		ArrayList<TiltAnimation.Rotation> resetRotations = new ArrayList<TiltAnimation.Rotation>();
		for(TiltAnimation.Rotation rotation : mLastRotations) {
			if(! contains(exceptAxises, rotation.mRotateAxis)) {
				resetRotations.add(new TiltAnimation.Rotation(rotation.mRotateAxis, rotation.mToDegrees, 0));
			}
		}
		return resetRotations.toArray(new TiltAnimation.Rotation[0]);
	}

	private boolean contains(int[] ints, int i) {
		if(ints == null || ints.length == 0) {
			return false;
		}
		for(int ii : ints) {
			if(i == ii)  {
				return true;
			}
		}
		return false;
	}

	private float getLastToDegreesByAxis(int axis) {
		if(mLastRotations == null || mLastRotations.isEmpty()) {
			return 0;
		}
		for(TiltAnimation.Rotation rotation : mLastRotations) {
			if(rotation.mRotateAxis == axis) {
				return rotation.mToDegrees;
			}
		}
		return 0;
	}


	private void applyTitlEffect(View view, TiltAnimation.Rotation[] resetRotations, float fromDegrees, float toDegrees, int axis) {
		applyTitlEffect(view, resetRotations, new TiltAnimation.Rotation(axis, fromDegrees, toDegrees));
	}

	private void applyTitlEffect(View view, TiltAnimation.Rotation ... rotations) {
		applyTitlEffect(view, null, rotations);
	}

	private void applyTitlEffect(View view, TiltAnimation.Rotation[] resetRotations, TiltAnimation.Rotation ... rotations) {
		final float centerX = view.getWidth() / 2.0f;
		final float centerY = view.getHeight() / 2.0f;

		final TiltAnimation rotation = new TiltAnimation(centerX, centerY);
		rotation.setDuration(200);
		rotation.setFillAfter(true);
		rotation.setInterpolator(new android.view.animation.DecelerateInterpolator());

		if(resetRotations != null) {
			rotation.addRotations(resetRotations);
		}
		rotation.addRotations(rotations);

		mLastRotations.clear();
		mLastRotations.addAll(Arrays.asList(rotations));

		view.startAnimation(rotation);
	}
  

public static class WaveDrawable extends android.graphics.drawable.Drawable implements android.graphics.drawable.Animatable, android.animation.ValueAnimator.AnimatorUpdateListener {

    private static final float WAVE_HEIGHT_FACTOR = 0.2f;
    private static final float WAVE_SPEED_FACTOR = 0.02f;
    private static final int UNDEFINED_VALUE = Integer.MIN_VALUE;
    private android.graphics.drawable.Drawable mDrawable;
    private int mWidth, mHeight;
    private int mWaveHeight = UNDEFINED_VALUE;
    private int mWaveLength = UNDEFINED_VALUE;
    private int mWaveStep = UNDEFINED_VALUE;
    private int mWaveOffset = 0;
    private int mWaveLevel = 0;
    private android.animation.ValueAnimator mAnimator = null;
    private float mProgress = 0.3f;
    private Paint mPaint;
    private Bitmap mMask;
    private Matrix mMatrix = new Matrix();
    private boolean mRunning = false;
    private boolean mIndeterminate = false;

    private static final PorterDuffXfermode sXfermode = new PorterDuffXfermode(PorterDuff.Mode.DST_IN);
    private static ColorFilter sGrayFilter = new ColorMatrixColorFilter(new float[]{
            0.264F, 0.472F, 0.088F, 0, 0,
            0.264F, 0.472F, 0.088F, 0, 0,
            0.264F, 0.472F, 0.088F, 0, 0,
            0,      0,      0,      1, 0
    });
    private ColorFilter mCurFilter = null;

    private Choreographer.FrameCallback mFrameCallback = new Choreographer.FrameCallback() {
        @Override
        public void doFrame(long l) {
            invalidateSelf();
            if (mRunning) {
                Choreographer.getInstance().postFrameCallback(this);
            }
        }
    };

    public WaveDrawable(android.graphics.drawable.Drawable drawable) {
        init(drawable);
    }

    @SuppressWarnings("deprecation")
    public WaveDrawable(Context context, int imgRes) {
        android.graphics.drawable.Drawable drawable;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            drawable = context.getDrawable(imgRes);
        } else {
            drawable = context.getResources().getDrawable(imgRes);
        }

        init(drawable);
    }

    private void init(android.graphics.drawable.Drawable drawable) {
        mDrawable = drawable;
        mMatrix.reset();
        mPaint = new Paint();
        mPaint.setFilterBitmap(false);
        mPaint.setColor(Color.BLACK);
        mPaint.setXfermode(sXfermode);

        mWidth = mDrawable.getIntrinsicWidth();
        mHeight = mDrawable.getIntrinsicHeight();

        if (mWidth > 0 && mHeight > 0) {
            mWaveLength = mWidth;
            mWaveHeight = Math.max(8, (int) (mHeight * WAVE_HEIGHT_FACTOR));
            mWaveStep = Math.max(1, (int) (mWidth * WAVE_SPEED_FACTOR));
            updateMask(mWidth, mWaveLength, mWaveHeight);
        }

        setProgress(0);
        start();
    }

    /**
     * Set wave move distance (in pixels) in very animation frame
     * @param step distance in pixels
     */
    public void setWaveSpeed(int step) {
        mWaveStep = Math.min(step, mWidth / 2);
    }

    /**
     * Set wave amplitude (in pixels)
     * @param amplitude
     */
    public void setWaveAmplitude(int amplitude) {
        amplitude = Math.max(1, Math.min(amplitude, mHeight / 2));
        int height = amplitude * 2;
        if (mWaveHeight != height) {
            mWaveHeight = height;
            updateMask(mWidth, mWaveLength, mWaveHeight);
            invalidateSelf();
        }
    }

    /**
     * Set wave length (in pixels)
     * @param length
     */
    public void setWaveLength(int length) {
        length = Math.max(8, Math.min(mWidth * 2, length));
        if (length != mWaveLength) {
            mWaveLength = length;
            updateMask(mWidth, mWaveLength, mWaveHeight);
            invalidateSelf();
        }
    }

    /**
     * Set the wave loading in indeterminate mode or not
     * @param indeterminate
     */
    public void setIndeterminate(boolean indeterminate) {
        mIndeterminate = indeterminate;
        if (mIndeterminate) {
            if (mAnimator == null) {
                mAnimator = getDefaultAnimator();
            }
            mAnimator.addUpdateListener(this);
            mAnimator.start();
        } else {
            if (mAnimator != null) {
                mAnimator.removeUpdateListener(this);
                mAnimator.cancel();
            }
            setLevel(calculateLevel());
        }
    }

    /**
     * Set customised animator for wave loading animation
     * @param animator
     */
    public void setIndeterminateAnimator(android.animation.ValueAnimator animator) {
        if (mAnimator == animator) {
            return;
        }

        if (mAnimator != null) {
            mAnimator.removeUpdateListener(this);
            mAnimator.cancel();
        }

        mAnimator = animator;
        if (mAnimator != null) {
            mAnimator.addUpdateListener(this);
        }
    }

    @Override
    public void setBounds(int left, int top, int right, int bottom) {
        super.setBounds(left, top, right, bottom);
        mDrawable.setBounds(left, top, right, bottom);
    }

    @Override
    protected void onBoundsChange(Rect bounds) {
        super.onBoundsChange(bounds);
        updateBounds(bounds);
    }

    private void updateBounds(Rect bounds) {
        if (bounds.width() <= 0 || bounds.height() <= 0) {
            return;
        }

        if (mWidth < 0 || mHeight < 0) {
            mWidth = bounds.width();
            mHeight = bounds.height();
            if (mWaveHeight == UNDEFINED_VALUE) {
                mWaveHeight = Math.max(8, (int) (mHeight * WAVE_HEIGHT_FACTOR));
            }

            if (mWaveLength == UNDEFINED_VALUE) {
                mWaveLength = mWidth;
            }

            if (mWaveStep == UNDEFINED_VALUE) {
                mWaveStep = Math.max(1, (int) (mWidth * WAVE_SPEED_FACTOR));
            }

            updateMask(mWidth, mWaveLength, mWaveHeight);
        }
    }

    @Override
    public int getIntrinsicHeight() {
        return mHeight;
    }

    @Override
    public int getIntrinsicWidth() {
        return mWidth;
    }

    @Override
    public void draw(Canvas canvas) {

        mDrawable.setColorFilter(sGrayFilter);
        mDrawable.draw(canvas);
        mDrawable.setColorFilter(mCurFilter);

        if (mProgress <= 0.001f) {
            return;
        }

        int sc = canvas.saveLayer(0, 0, mWidth, mHeight, null,
                Canvas.MATRIX_SAVE_FLAG |
                Canvas.CLIP_SAVE_FLAG |
                Canvas.HAS_ALPHA_LAYER_SAVE_FLAG |
                Canvas.FULL_COLOR_LAYER_SAVE_FLAG |
                Canvas.CLIP_TO_LAYER_SAVE_FLAG);

        if (mWaveLevel > 0) {
            canvas.clipRect(0, mWaveLevel, mWidth, mHeight);
        }

        mDrawable.draw(canvas);

        if (mProgress >= 0.999f) {
            return;
        }

        mWaveOffset += mWaveStep;
        if (mWaveOffset > mWaveLength) {
            mWaveOffset -= mWaveLength;
        }

        if (mMask != null) {
            mMatrix.setTranslate(-mWaveOffset, mWaveLevel);
            canvas.drawBitmap(mMask, mMatrix, mPaint);
        }

        canvas.restoreToCount(sc);
    }

    @Override
    protected boolean onLevelChange(int level) {
        setProgress(level / 10000f);
        return true;
    }

    @Override
    public void setAlpha(int i) {
        mDrawable.setAlpha(i);
    }

    @Override
    public void setColorFilter(ColorFilter colorFilter) {
        mCurFilter = colorFilter;
        invalidateSelf();
    }

    @Override
    public int getOpacity() {
        return PixelFormat.TRANSLUCENT;
    }

    @Override
    public void start() {
        mRunning = true;
        Choreographer.getInstance().postFrameCallback(mFrameCallback);
    }

    @Override
    public void stop() {
        mRunning = false;
        Choreographer.getInstance().removeFrameCallback(mFrameCallback);
    }

    @Override
    public boolean isRunning() {
        return mRunning;
    }

    @Override
    public void onAnimationUpdate(android.animation.ValueAnimator animation) {
        if (mIndeterminate) {
            setProgress(animation.getAnimatedFraction());
            if (!mRunning) {
                invalidateSelf();
            }
        }
    }

    public boolean isIndeterminate() {
        return mIndeterminate;
    }

    private android.animation.ValueAnimator getDefaultAnimator() {
        android.animation.ValueAnimator animator = android.animation.ValueAnimator.ofFloat(0, 1);
        animator.setInterpolator(new android.view.animation.DecelerateInterpolator());
        animator.setRepeatMode(android.animation.ValueAnimator.RESTART);
        animator.setRepeatCount(android.animation.ValueAnimator.INFINITE);
        animator.setDuration(5000);
        return animator;
    }

    private void setProgress(float progress) {
        mProgress = progress;
        mWaveLevel = mHeight - (int)((mHeight + mWaveHeight) * mProgress);
        invalidateSelf();
    }

    private int calculateLevel() {
        return (mHeight - mWaveLevel) * 10000 / (mHeight + mWaveHeight);
    }

    private void updateMask(int width, int length, int height) {
        if (width <= 0 || length <= 0 || height <= 0) {
            //showMessage("updateMask: size must > 0");
            mMask = null;
            return;
        }


        final int count = (int) Math.ceil((width + length) / (float)length);

        Bitmap bm = Bitmap.createBitmap(length * count, height, Bitmap.Config.ARGB_8888);
        Canvas c = new Canvas(bm);
        Paint p = new Paint(Paint.ANTI_ALIAS_FLAG);

        int amplitude = height / 2;
        Path path = new Path();
        path.moveTo(0, amplitude);

        final float stepX = length / 4f;
        float x = 0;
        float y = -amplitude;
        for (int i = 0; i < count * 2; i++) {
            x += stepX;
            path.quadTo(x, y, x+stepX, amplitude);
            x += stepX;
            y = bm.getHeight() - y;
        }
        path.lineTo(bm.getWidth(), height);
        path.lineTo(0, height);
        path.close();

        c.drawPath(path, p);

        mMask = bm;
    }
}



//EXAMPLE
//Create New
final WaveDrawable mWaveDrawable = new WaveDrawable(MainActivity.this, R.drawable.chrome_logo);

//Set to ImageView
imageview1.setImageDrawable(mWaveDrawable);

//Config
mWaveDrawable.setLevel(4000); //max 10000
mWaveDrawable.setWaveAmplitude(20); //max 100
mWaveDrawable.setWaveLength(200); //max 600
mWaveDrawable.setWaveSpeed(5); //max 50
mWaveDrawable.setIndeterminate(false);



//Other configurable APIs:
* public void setWaveAmplitude(int amplitude), set wave amplitude (in pixels)
* public void setWaveLength(int length), set wave length (in pixels)
* public void setWaveSpeed(int step), set wave move speed (in pixels)
* public void setIndeterminate(boolean indeterminate), like progress bar, if run
in *indeterminate* mode, it'll increase water level over and over again, otherwise, you can
use boolean setLevel(int level) to set the water level, acting as loading progress.
* public void setIndeterminateAnimator(ValueAnimator animator), set you customised animator
for wave loading animation in indeterminate mode.
}


public static class Utils {

    public static int SCREEN_WIDTH_PIXELS;
    public static int SCREEN_HEIGHT_PIXELS;
    public static float SCREEN_DENSITY;
    public static int SCREEN_WIDTH_DP;
    public static int SCREEN_HEIGHT_DP;
    private static boolean sInitialed;

    public static void init(Context context) {
        if (sInitialed || context == null) {
            return;
        }
        sInitialed = true;
        DisplayMetrics dm = new DisplayMetrics();
        WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
        wm.getDefaultDisplay().getMetrics(dm);
        SCREEN_WIDTH_PIXELS = dm.widthPixels;
        SCREEN_HEIGHT_PIXELS = dm.heightPixels;
        SCREEN_DENSITY = dm.density;
        SCREEN_WIDTH_DP = (int) (SCREEN_WIDTH_PIXELS / dm.density);
        SCREEN_HEIGHT_DP = (int) (SCREEN_HEIGHT_PIXELS / dm.density);
    }

    public static int dp2px(float dp) {
        final float scale = SCREEN_DENSITY;
        return (int) (dp * scale + 0.5f);
    }

    public static int designedDP2px(float designedDp) {
        if (SCREEN_WIDTH_DP != 320) {
            designedDp = designedDp * SCREEN_WIDTH_DP / 320f;
        }
        return dp2px(designedDp);
    }

    public static void setPadding(final View view, float left, float top, float right, float bottom) {
        view.setPadding(designedDP2px(left), dp2px(top), designedDP2px(right), dp2px(bottom));
    }
}


public class MatchItem extends Animation {

    public PointF midPoint;
    public float translationX;
    public int index;

    private final Paint mPaint = new Paint();
    private float mFromAlpha = 1.0f;
    private float mToAlpha = 0.4f;
    private PointF mCStartPoint;
    private PointF mCEndPoint;

    public MatchItem(int index, PointF start, PointF end, int color, int lineWidth) {
        this.index = index;

        midPoint = new PointF((start.x + end.x) / 2, (start.y + end.y) / 2);

        mCStartPoint = new PointF(start.x - midPoint.x, start.y - midPoint.y);
        mCEndPoint = new PointF(end.x - midPoint.x, end.y - midPoint.y);

        setColor(color);
        setLineWidth(lineWidth);
        mPaint.setAntiAlias(true);
        mPaint.setStyle(Paint.Style.STROKE);
    }

    public void setLineWidth(int width) {
        mPaint.setStrokeWidth(width);
    }

    public void setColor(int color) {
        mPaint.setColor(color);
    }

    public void resetPosition(int horizontalRandomness) {
        Random random = new Random();
        int randomNumber = -random.nextInt(horizontalRandomness) + horizontalRandomness;
        translationX = randomNumber;
    }

    @Override
    protected void applyTransformation(float interpolatedTime, Transformation t) {
        float alpha = mFromAlpha;
        alpha = alpha + ((mToAlpha - alpha) * interpolatedTime);
        setAlpha(alpha);
    }

    public void start(float fromAlpha, float toAlpha) {
        mFromAlpha = fromAlpha;
        mToAlpha = toAlpha;
        super.start();
    }

    public void setAlpha(float alpha) {
        mPaint.setAlpha((int) (alpha * 255));
    }

    public void draw(Canvas canvas) {
        canvas.drawLine(mCStartPoint.x, mCStartPoint.y, mCEndPoint.x, mCEndPoint.y, mPaint);
    }
}


public static class MatchPath {

    private static final SparseArray<float[]> sPointList;

    public static final char V_LEFT = '#';
    public static final char H_TOP_BOTTOM = '\$';
    public static final char V_RIGHT = '%';


    static {
        sPointList = new SparseArray<float[]>();
        float[][] LETTERS = new float[][]{
                new float[]{
                        // A
                        24, 0, 1, 22,
                        1, 22, 1, 72,
                        24, 0, 47, 22,
                        47, 22, 47, 72,
                        1, 48, 47, 48
                },

                new float[]{
                        // B
                        0, 0, 0, 72,
                        0, 0, 37, 0,
                        37, 0, 47, 11,
                        47, 11, 47, 26,
                        47, 26, 38, 36,
                        38, 36, 0, 36,
                        38, 36, 47, 46,
                        47, 46, 47, 61,
                        47, 61, 38, 71,
                        37, 72, 0, 72,
                },

                new float[]{
                        // C
                        47, 0, 0, 0,
                        0, 0, 0, 72,
                        0, 72, 47, 72,
                },

                new float[]{
                        // D
                        0, 0, 0, 72,
                        0, 0, 24, 0,
                        24, 0, 47, 22,
                        47, 22, 47, 48,
                        47, 48, 23, 72,
                        23, 72, 0, 72,
                },

                new float[]{
                        // E
                        0, 0, 0, 72,
                        0, 0, 47, 0,
                        0, 36, 37, 36,
                        0, 72, 47, 72,
                },

                new float[]{
                        // F
                        0, 0, 0, 72,
                        0, 0, 47, 0,
                        0, 36, 37, 36,
                },

                new float[]{
                        // G
                        47, 23, 47, 0,
                        47, 0, 0, 0,
                        0, 0, 0, 72,
                        0, 72, 47, 72,
                        47, 72, 47, 48,
                        47, 48, 24, 48,
                },

                new float[]{
                        // H
                        0, 0, 0, 72,
                        0, 36, 47, 36,
                        47, 0, 47, 72,
                },

                new float[]{
                        // I
                        0, 0, 47, 0,
                        24, 0, 24, 72,
                        0, 72, 47, 72,
                },

                new float[]{
                        // J
                        47, 0, 47, 72,
                        47, 72, 24, 72,
                        24, 72, 0, 48,
                },

                new float[]{
                        // K
                        0, 0, 0, 72,
                        47, 0, 3, 33,
                        3, 38, 47, 72,
                },

                new float[]{
                        // L
                        0, 0, 0, 72,
                        0, 72, 47, 72,
                },

                new float[]{
                        // M
                        0, 0, 0, 72,
                        0, 0, 24, 23,
                        24, 23, 47, 0,
                        47, 0, 47, 72,
                },

                new float[]{
                        // N
                        0, 0, 0, 72,
                        0, 0, 47, 72,
                        47, 72, 47, 0,
                },

                new float[]{
                        // O
                        0, 0, 0, 72,
                        0, 72, 47, 72,
                        47, 72, 47, 0,
                        47, 0, 0, 0,
                },

                new float[]{
                        // P
                        0, 0, 0, 72,
                        0, 0, 47, 0,
                        47, 0, 47, 36,
                        47, 36, 0, 36,
                },

                new float[]{
                        // Q
                        0, 0, 0, 72,
                        0, 72, 23, 72,
                        23, 72, 47, 48,
                        47, 48, 47, 0,
                        47, 0, 0, 0,
                        24, 28, 47, 71,
                },

                new float[]{
                        // R
                        0, 0, 0, 72,
                        0, 0, 47, 0,
                        47, 0, 47, 36,
                        47, 36, 0, 36,
                        0, 37, 47, 72,
                },

                new float[]{
                        // S
                        47, 0, 0, 0,
                        0, 0, 0, 36,
                        0, 36, 47, 36,
                        47, 36, 47, 72,
                        47, 72, 0, 72,
                },

                new float[]{
                        // T
                        0, 0, 47, 0,
                        24, 0, 24, 72,
                },

                new float[]{
                        // U
                        0, 0, 0, 72,
                        0, 72, 47, 72,
                        47, 72, 47, 0,
                },

                new float[]{
                        // V
                        0, 0, 24, 72,
                        24, 72, 47, 0,
                },

                new float[]{
                        // W
                        0, 0, 0, 72,
                        0, 72, 24, 49,
                        24, 49, 47, 72,
                        47, 72, 47, 0
                },

                new float[]{
                        // X
                        0, 0, 47, 72,
                        47, 0, 0, 72
                },

                new float[]{
                        // Y
                        0, 0, 24, 23,
                        47, 0, 24, 23,
                        24, 23, 24, 72
                },

                new float[]{
                        // Z
                        0, 0, 47, 0,
                        47, 0, 0, 72,
                        0, 72, 47, 72
                },
        };
        final float[][] NUMBERS = new float[][]{
                new float[]{
                        // 0
                        0, 0, 0, 72,
                        0, 72, 47, 72,
                        47, 72, 47, 0,
                        47, 0, 0, 0,
                },
                new float[]{
                        // 1
                        24, 0, 24, 72,
                },

                new float[]{
                        // 2
                        0, 0, 47, 0,
                        47, 0, 47, 36,
                        47, 36, 0, 36,
                        0, 36, 0, 72,
                        0, 72, 47, 72
                },

                new float[]{
                        // 3
                        0, 0, 47, 0,
                        47, 0, 47, 36,
                        47, 36, 0, 36,
                        47, 36, 47, 72,
                        47, 72, 0, 72,
                },

                new float[]{
                        // 4
                        0, 0, 0, 36,
                        0, 36, 47, 36,
                        47, 0, 47, 72,
                },

                new float[]{
                        // 5
                        0, 0, 0, 36,
                        0, 36, 47, 36,
                        47, 36, 47, 72,
                        47, 72, 0, 72,
                        0, 0, 47, 0
                },

                new float[]{
                        // 6
                        0, 0, 0, 72,
                        0, 72, 47, 72,
                        47, 72, 47, 36,
                        47, 36, 0, 36
                },

                new float[]{
                        // 7
                        0, 0, 47, 0,
                        47, 0, 47, 72
                },

                new float[]{
                        // 8
                        0, 0, 0, 72,
                        0, 72, 47, 72,
                        47, 72, 47, 0,
                        47, 0, 0, 0,
                        0, 36, 47, 36
                },

                new float[]{
                        // 9
                        47, 0, 0, 0,
                        0, 0, 0, 36,
                        0, 36, 47, 36,
                        47, 0, 47, 72,
                }
        };
        // A - Z
        for (int i = 0; i < LETTERS.length; i++) {
            sPointList.append(i + 65, LETTERS[i]);
        }
        // a - z
        for (int i = 0; i < LETTERS.length; i++) {
            sPointList.append(i + 65 + 32, LETTERS[i]);
        }
        // 0 - 9
        for (int i = 0; i < NUMBERS.length; i++) {
            sPointList.append(i + 48, NUMBERS[i]);
        }
        // blank
        addChar(' ', new float[]{});
        // -
        addChar('-', new float[]{
                0, 36, 47, 36
        });
        // .
        addChar('.', new float[]{
                24, 60, 24, 72
        });

        addChar(V_LEFT, new float[]{
                -12, 120, -12, 38,
                -12, 38, -12, -45
        });
        addChar(H_TOP_BOTTOM, new float[]{
                0, -45, 23, -45,
                23, -45, 67, -45,
                0, 120, 23, 120,
                23, 120, 67, 120
        });
        addChar(V_RIGHT, new float[]{
                79, -45, 79, 38,
                79, 38, 79, 120
        });
    }

    public static void addChar(char c, float[] points) {
        sPointList.append(c, points);
    }

    public static ArrayList<float[]> getPath(String str) {
        return getPath(str, 1, 14);
    }

    public static boolean isButtonModle;

    /**
     * @param str
     * @param scale
     * @param gapBetweenLetter
     * @return ArrayList of float[] {x1, y1, x2, y2}
     */
    public static ArrayList<float[]> getPath(String str, float scale, int gapBetweenLetter) {
        ArrayList<float[]> list = new ArrayList<float[]>();
        float offsetForWidth = 0;
        for (int i = 0; i < str.length(); i++) {
            int pos = str.charAt(i);
            int key = sPointList.indexOfKey(pos);
            if (key == -1) {
                continue;
            }
            float[] points = sPointList.get(pos);

            if (isButtonModle) {
                float[] points1 = new float[points.length + 16];
                for (int j = 0; j < sPointList.get(H_TOP_BOTTOM).length; j++) {
                    points1[j] = sPointList.get(H_TOP_BOTTOM)[j];
                }
                for (int j = 0; j < points.length; j++) {
                    points1[j + 16] = points[j];
                }
                points = points1;
            }

            int pointCount = points.length / 4;
            for (int j = 0; j < pointCount; j++) {
                float[] line = new float[4];
                for (int k = 0; k < 4; k++) {
                    float l = points[j * 4 + k];
                    // x
                    if (k % 2 == 0) {
                        line[k] = (l + offsetForWidth) * scale;
                    }
                    // y
                    else {
                        line[k] = l * scale;
                    }
                }
                list.add(line);
            }
            offsetForWidth += 57 + gapBetweenLetter;
        }

        if (isButtonModle) {
            isButtonModle = false;
        }
        return list;
    }
}


public class MatchView extends View {
    //
    public ArrayList<MatchItem> mItemList = new ArrayList<MatchItem>();

    private int mLineWidth;
    private float mScale = 1;
    private int mDropHeight;
    private float internalAnimationFactor = 0.7f;
    private int horizontalRandomness;

    private float mProgress = 0;

    private int mDrawZoneWidth = 0;
    private int mDrawZoneHeight = 0;
    private int mOffsetX = 0;
    private int mOffsetY = 0;
    private float mBarDarkAlpha = 0.4f;
    private float mFromAlpha = 1.0f;
    private float mToAlpha = 0.4f;

    private int mLoadingAniDuration = 1000;
    private int mLoadingAniSegDuration = 1000;
    private int mLoadingAniItemDuration = 400;

    private Transformation mTransformation = new Transformation();
    private boolean mIsInLoading = false;
    private AniController mAniController = new AniController();
    private int mTextColor = Color.WHITE;
    private Handler mHandler;
    private float progress = 0;
    private float mInTime = 0.8f;
    private float mOutTime = 0.8f;
    private boolean isBeginLight = true;
    private int mPaddingTop = 15;
    private float mTextSize = 25f;

    /**
     */
    private int STATE = 0;

    private MatchInListener mMatchInListener;
    private MatchOutListener mMatchOutListener;

    public void setMatchInListener(MatchInListener mMatchInListener) {
        this.mMatchInListener = mMatchInListener;
    }

    public void setMatchOutListener(MatchOutListener mMatchOutListener) {
        this.mMatchOutListener = mMatchOutListener;
    }

    public MatchView(Context context) {

        super(context);
        initView();
    }

    public MatchView(Context context, AttributeSet attrs) {
        super(context, attrs);
        initView();
    }

    public MatchView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        initView();
    }

    private void initView() {
        this.setLayerType(View.LAYER_TYPE_SOFTWARE, null);
        Utils.init(getContext());
        mLineWidth = Utils.dp2px(1);
        mDropHeight = Utils.dp2px(40);
        horizontalRandomness = Utils.SCREEN_WIDTH_PIXELS / 2;

        setPadding(0, Utils.dp2px(mPaddingTop), 0, Utils.dp2px(mPaddingTop));

        mHandler = new Handler() {
            @Override
            public void dispatchMessage(Message msg) {
                super.dispatchMessage(msg);
                if (STATE == 1) {
                    if (progress < 100) {
                        progress++;
                        setProgress((progress * 1f / (100)));
                        mHandler.sendEmptyMessageDelayed(0, (long) (mInTime * 10));
                    } else {
                        STATE = 2;
                        if (mMatchInListener != null) {
                            mMatchInListener.onFinish();
                        }
                    }
                } else if (STATE == 2) {
                    if (mIsInLoading) {
                        lightFinish();
                    }
                    if (progress > 0) {
                        progress--;
                        setProgress((progress * 1f / (100)));
                        mHandler.sendEmptyMessageDelayed(0, (long) (mOutTime * 10));
                    } else {
                        progress = 0;
                        if (mMatchOutListener != null) {
                            mMatchOutListener.onFinish();
                        }
                        STATE = 1;
                    }
                }
            }
        };
    }

    public void setInTime(float mTime) {
        mInTime = mTime;
    }

    public void setOutTime(float mTime) {
        mOutTime = mTime;
    }

    public void setLight(boolean isLight) {
        isBeginLight = isLight;
    }

    public void setPaddingTop(int dp) {
        mPaddingTop = dp;
    }

    public void setTextSize(float mTextSize) {
        this.mTextSize = mTextSize;
    }

    protected void show() {
        if (mItemList.size() == 0) {
            return;
        }
        STATE = 1;
        mHandler.sendEmptyMessage(0);
        if (mMatchInListener != null) {
            mMatchInListener.onBegin();
        }
    }

    public void hide() {
        if (mMatchOutListener != null) {
            mMatchOutListener.onBegin();
        }
        mHandler.sendEmptyMessage(0);
    }

    public void setProgress(float progress) {
        if (mMatchInListener != null && STATE == 1) {
            mMatchInListener.onProgressUpdate(progress);
        } else if (mMatchOutListener != null && STATE == 2) {
            mMatchOutListener.onProgressUpdate(progress);
        }

        if (progress == 1) {
            if (isBeginLight) {
                beginLight();
            }
        } else if (mIsInLoading) {
            lightFinish();
        }
        mProgress = progress;
        postInvalidate();
    }

    public int getLoadingAniDuration() {
        return mLoadingAniDuration;
    }

    public void setLoadingAniDuration(int duration) {
        mLoadingAniDuration = duration;
        mLoadingAniSegDuration = duration;
    }

    public MatchView setLineWidth(int width) {
        mLineWidth = width;
        for (int i = 0; i < mItemList.size(); i++) {
            mItemList.get(i).setLineWidth(width);
        }
        return this;
    }

    public MatchView setTextColor(int color) {
        mTextColor = color;
        for (int i = 0; i < mItemList.size(); i++) {
            mItemList.get(i).setColor(color);
        }
        return this;
    }

    public MatchView setDropHeight(int height) {
        mDropHeight = height;
        return this;
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        int height = getTopOffset() + mDrawZoneHeight + getBottomOffset();
        heightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY);
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);

        mOffsetX = (getMeasuredWidth() - mDrawZoneWidth) / 2;
        mOffsetY = getTopOffset();
        mDropHeight = getTopOffset();
    }

    private int getTopOffset() {
        return getPaddingTop() + Utils.dp2px(10);
    }

    private int getBottomOffset() {
        return getPaddingBottom() + Utils.dp2px(10);
    }

    public void initWithString(String str) {
        initWithString(str, mTextSize);
    }

    public void initWithString(String str, float fontSize) {
        ArrayList<float[]> pointList = MatchPath.getPath(str, fontSize * 0.01f, 14);
        initWithPointList(pointList);
    }

    public void initWithStringArray(int id) {
        String[] points = getResources().getStringArray(id);
        ArrayList<float[]> pointList = new ArrayList<float[]>();
        for (int i = 0; i < points.length; i++) {
            String[] x = points[i].split(",");
            float[] f = new float[4];
            for (int j = 0; j < 4; j++) {
                f[j] = Float.parseFloat(x[j]);
            }
            pointList.add(f);
        }
        initWithPointList(pointList);
    }

    public float getScale() {
        return mScale;
    }

    public void setScale(float scale) {
        mScale = scale;
    }

    public void initWithPointList(ArrayList<float[]> pointList) {

        float drawWidth = 0;
        float drawHeight = 0;
        boolean shouldLayout = mItemList.size() > 0;
        mItemList.clear();
        for (int i = 0; i < pointList.size(); i++) {
            float[] line = pointList.get(i);
            PointF startPoint = new PointF(Utils.dp2px(line[0]) * mScale, Utils.dp2px(line[1]) * mScale);
            PointF endPoint = new PointF(Utils.dp2px(line[2]) * mScale, Utils.dp2px(line[3]) * mScale);

            drawWidth = Math.max(drawWidth, startPoint.x);
            drawWidth = Math.max(drawWidth, endPoint.x);

            drawHeight = Math.max(drawHeight, startPoint.y);
            drawHeight = Math.max(drawHeight, endPoint.y);

            MatchItem item = new MatchItem(i, startPoint, endPoint, mTextColor, mLineWidth);
            item.resetPosition(horizontalRandomness);
            mItemList.add(item);
        }
        mDrawZoneWidth = (int) Math.ceil(drawWidth);
        mDrawZoneHeight = (int) Math.ceil(drawHeight);
        if (shouldLayout) {
            requestLayout();
        }
    }

    public void beginLight() {
        mIsInLoading = true;
        mAniController.start();
        invalidate();
    }

    public void lightFinish() {
        mIsInLoading = false;
        mAniController.stop();
    }

    @Override
    public void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        float progress = mProgress;
        int c1 = canvas.save();
        int len = mItemList.size();
        for (int i = 0; i < mItemList.size(); i++) {
            canvas.save();
            MatchItem LoadingViewItem = mItemList.get(i);
            float offsetX = mOffsetX + LoadingViewItem.midPoint.x;
            float offsetY = mOffsetY + LoadingViewItem.midPoint.y;

            if (mIsInLoading) {
                LoadingViewItem.getTransformation(getDrawingTime(), mTransformation);
                canvas.translate(offsetX, offsetY);
            } else {

                if (progress == 0) {
                    LoadingViewItem.resetPosition(horizontalRandomness);
                    continue;
                }

                float startPadding = (1 - internalAnimationFactor) * i / len;
                float endPadding = 1 - internalAnimationFactor - startPadding;

                // done
                if (progress == 1 || progress >= 1 - endPadding) {
                    canvas.translate(offsetX, offsetY);
                    LoadingViewItem.setAlpha(mBarDarkAlpha);
                } else {
                    float realProgress;
                    if (progress <= startPadding) {
                        realProgress = 0;
                    } else {
                        realProgress = Math.min(1, (progress - startPadding) / internalAnimationFactor);
                    }
                    offsetX += LoadingViewItem.translationX * (1 - realProgress);
                    offsetY += -mDropHeight * (1 - realProgress);
                    Matrix matrix = new Matrix();
                    matrix.postRotate(360 * realProgress);
                    matrix.postScale(realProgress, realProgress);
                    matrix.postTranslate(offsetX, offsetY);
                    LoadingViewItem.setAlpha(mBarDarkAlpha * realProgress);
                    canvas.concat(matrix);
                }
            }
            LoadingViewItem.draw(canvas);
            canvas.restore();
        }
        if (mIsInLoading) {
            invalidate();
        }
        canvas.restoreToCount(c1);
    }

    private class AniController implements Runnable {

        private int mTick = 0;
        private int mCountPerSeg = 0;
        private int mSegCount = 0;
        private int mInterval = 0;
        private boolean mRunning = true;

        private void start() {
            mRunning = true;
            mTick = 0;

            mInterval = mLoadingAniDuration / mItemList.size();
            mCountPerSeg = mLoadingAniSegDuration / mInterval;
            mSegCount = mItemList.size() / mCountPerSeg + 1;
            run();
        }

        @Override
        public void run() {

            int pos = mTick % mCountPerSeg;
            for (int i = 0; i < mSegCount; i++) {

                int index = i * mCountPerSeg + pos;
                if (index > mTick) {
                    continue;
                }

                index = index % mItemList.size();
                MatchItem item = mItemList.get(index);

                item.setFillAfter(false);
                item.setFillEnabled(true);
                item.setFillBefore(false);
                item.setDuration(mLoadingAniItemDuration);
                item.start(mFromAlpha, mToAlpha);
            }

            mTick++;
            if (mRunning) {
                postDelayed(this, mInterval);
            }
        }

        private void stop() {
            mRunning = false;
            removeCallbacks(this);
        }
    }

    
    }
public interface MatchInListener {
        public void onBegin();

        public void onProgressUpdate(float progress);

        public void onFinish();
    }

    public interface MatchOutListener {
        public void onBegin();

        public void onProgressUpdate(float progress);

        public void onFinish();
    }


//textView
public class MatchTextView extends MatchView {

    String mContent;
    float mTextSize;
    int mTextColor;

    public MatchTextView(Context context) {
        super(context);
        init();
    }

    public MatchTextView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }      
        

    public MatchTextView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }
    void init() {
        this.setBackgroundColor(Color.TRANSPARENT);
        if (!TextUtils.isEmpty(mContent)) {
            setTextColor(Color.WHITE);
            setTextSize(25);
            initWithString(mContent);
            show();
        }
    }


    public void setText(String text) {
        this.mContent = text;
        init();
    }

}

public class MatchButton extends MatchTextView {


    public MatchButton(Context context) {
        super(context);
        init();
    }

    public MatchButton(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public MatchButton(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    @Override
    void init() {
        PraseText();
        super.init();
    }

    void PraseText() {
        if (!TextUtils.isEmpty(mContent)) {
            MatchPath.isButtonModle = true;
            StringBuffer strBuffer = new StringBuffer();
            strBuffer.append(MatchPath.V_LEFT);
            strBuffer.append(mContent);
            strBuffer.append(MatchPath.V_RIGHT);
            this.mContent = strBuffer.toString();
        }
    }
}
/*Nah Bro*/
}



final static class ToastyUtils {
    private ToastyUtils() {
    }

    static android.graphics.drawable.Drawable tintIcon(android.graphics.drawable.Drawable drawable, int tintColor) {
        drawable.setColorFilter(tintColor, PorterDuff.Mode.SRC_IN);
        return drawable;
    }

    static android.graphics.drawable.Drawable tint9PatchDrawableFrame(Context context, int tintColor) {
        final android.graphics.drawable.NinePatchDrawable toastDrawable = (android.graphics.drawable.NinePatchDrawable) getDrawable(context, R.drawable.toast_frame);
        return tintIcon(toastDrawable, tintColor);
    }

    static void setBackground(View view, android.graphics.drawable.Drawable drawable) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN)
            view.setBackground(drawable);
        else
            view.setBackgroundDrawable(drawable);
    }

    static android.graphics.drawable.Drawable getDrawable(Context context, int id) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)
            return context.getDrawable(id);
        else
            return context.getResources().getDrawable(id);
    }
}





public static class Toasty {
    
    private static int DEFAULT_TEXT_COLOR = Color.parseColor("#FFFFFF");
    
    private static int ERROR_COLOR = Color.parseColor("#D50000");
    
    private static int INFO_COLOR = Color.parseColor("#3F51B5");
    
    private static int SUCCESS_COLOR = Color.parseColor("#388E3C");
    
    private static int WARNING_COLOR = Color.parseColor("#FFA900");
    
    private static int NORMAL_COLOR = Color.parseColor("#353A3E");

    private static final Typeface LOADED_TOAST_TYPEFACE = Typeface.create("sans-serif-condensed", Typeface.NORMAL);
    private static Typeface currentTypeface = LOADED_TOAST_TYPEFACE;
    private static int textSize = 16; // in SP

    private static boolean tintIcon = true;

    private Toasty() {
        // avoiding instantiation
    }


    public static Toast normal(Context context, CharSequence message) {
        return normal(context, message, Toast.LENGTH_SHORT, null, false);
    }

    
    public static Toast normal(Context context, CharSequence message, android.graphics.drawable.Drawable icon) {
        return normal(context, message, Toast.LENGTH_SHORT, icon, true);
    }

    public static Toast normal(Context context, CharSequence message, int duration) {
        return normal(context, message, duration, null, false);
    }


    public static Toast normal(Context context, CharSequence message, int duration,
                               android.graphics.drawable.Drawable icon) {
        return normal(context, message, duration, icon, true);
    }


    public static Toast normal(Context context, CharSequence message, int duration,
                               android.graphics.drawable.Drawable icon, boolean withIcon) {
        return custom(context, message, icon, NORMAL_COLOR, duration, withIcon, true);
    }


    public static Toast warning(Context context, CharSequence message) {
        return warning(context, message, Toast.LENGTH_SHORT, true);
    }
    

    public static Toast warning(Context context, CharSequence message, int duration) {
        return warning(context, message, duration, true);
    }

    public static Toast warning(Context context, CharSequence message, int duration, boolean withIcon) {
        return custom(context, message, ToastyUtils.getDrawable(context, R.drawable.ic_error_outline_white_48dp),
                WARNING_COLOR, duration, withIcon, true);
    }

    public static Toast info(Context context, CharSequence message) {
        return info(context, message, Toast.LENGTH_SHORT, true);
    }

    
    public static Toast info(Context context, CharSequence message, int duration) {
        return info(context, message, duration, true);
    }


    public static Toast info(Context context, CharSequence message, int duration, boolean withIcon) {
        return custom(context, message, ToastyUtils.getDrawable(context, R.drawable.ic_info_outline_white_48dp),
                INFO_COLOR, duration, withIcon, true);
    }

     
    public static Toast success(Context context, CharSequence message) {
        return success(context, message, Toast.LENGTH_SHORT, true);
    }

     
    public static Toast success(Context context, CharSequence message, int duration) {
        return success(context, message, duration, true);
    }

     
    public static Toast success(Context context, CharSequence message, int duration, boolean withIcon) {
        return custom(context, message, ToastyUtils.getDrawable(context, R.drawable.ic_check_white_48dp),
               SUCCESS_COLOR, duration, withIcon, true);
    }

     
    public static Toast error(Context context, CharSequence message) {
        return error(context, message, Toast.LENGTH_SHORT, true);
    }

     
    public static Toast error(Context context, CharSequence message, int duration) {
        return error(context, message, duration, true);
    }

     
    public static Toast error(Context context, CharSequence message, int duration, boolean withIcon) {
        return custom(context, message, ToastyUtils.getDrawable(context, R.drawable.ic_clear_white_48dp),
                ERROR_COLOR, duration, withIcon, true);
    }

     
    public static Toast custom(Context context, CharSequence message, android.graphics.drawable.Drawable icon,
                               int duration, boolean withIcon) {
        return custom(context, message, icon, -1, duration, withIcon, false);
    }

     
    public static Toast custom(Context context, CharSequence message, int iconRes,
                               int tintColor, int duration,
                               boolean withIcon, boolean shouldTint) {
        return custom(context, message, ToastyUtils.getDrawable(context, iconRes),
                tintColor, duration, withIcon, shouldTint);
    }

     
    public static Toast custom(Context context, CharSequence message, android.graphics.drawable.Drawable icon,
                               int tintColor, int duration,
                               boolean withIcon, boolean shouldTint) {
        final Toast currentToast = new Toast(context);
        final View toastLayout = ((LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE))
                .inflate(R.layout.toast_layout, null);
        final ImageView toastIcon = (ImageView) toastLayout.findViewById(R.id.toast_icon);
        final TextView toastTextView = (TextView) toastLayout.findViewById(R.id.toast_text);
        android.graphics.drawable.Drawable drawableFrame;

        if (shouldTint)
            drawableFrame = ToastyUtils.tint9PatchDrawableFrame(context, tintColor);
        else
            drawableFrame = ToastyUtils.getDrawable(context, R.drawable.toast_frame);
        ToastyUtils.setBackground(toastLayout, drawableFrame);

        if (withIcon) {
            if (icon == null)
                throw new IllegalArgumentException("Avoid passing 'icon' as null if 'withIcon' is set to true");
            if (tintIcon)
                icon = ToastyUtils.tintIcon(icon, DEFAULT_TEXT_COLOR);
            ToastyUtils.setBackground(toastIcon, icon);
        } else {
            toastIcon.setVisibility(View.GONE);
        }

        toastTextView.setText(message);
        toastTextView.setTextColor(DEFAULT_TEXT_COLOR);
        toastTextView.setTypeface(currentTypeface);
        toastTextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, textSize);

        currentToast.setDuration(duration);
        currentToast.setView(toastLayout);
        return currentToast;
    }

    public static class Config {
        
        private int DEFAULT_TEXT_COLOR = Toasty.DEFAULT_TEXT_COLOR;
        
        private int ERROR_COLOR = Toasty.ERROR_COLOR;
        
        private int INFO_COLOR = Toasty.INFO_COLOR;
        
        private int SUCCESS_COLOR = Toasty.SUCCESS_COLOR;
        
        private int WARNING_COLOR = Toasty.WARNING_COLOR;

        private Typeface typeface = Toasty.currentTypeface;
        private int textSize = Toasty.textSize;

        private boolean tintIcon = Toasty.tintIcon;

        private Config() {
            // avoiding instantiation
        }

         
        public static Config getInstance() {
            return new Config();
        }

        public static void reset() {
            Toasty.DEFAULT_TEXT_COLOR = Color.parseColor("#FFFFFF");
            Toasty.ERROR_COLOR = Color.parseColor("#D50000");
            Toasty.INFO_COLOR = Color.parseColor("#3F51B5");
            Toasty.SUCCESS_COLOR = Color.parseColor("#388E3C");
            Toasty.WARNING_COLOR = Color.parseColor("#FFA900");
            Toasty.currentTypeface = LOADED_TOAST_TYPEFACE;
            Toasty.textSize = 16;
            Toasty.tintIcon = true;
        }

         
        public Config setTextColor(int textColor) {
            DEFAULT_TEXT_COLOR = textColor;
            return this;
        }

         
        public Config setErrorColor(int errorColor) {
            ERROR_COLOR = errorColor;
            return this;
        }

         
        public Config setInfoColor(int infoColor) {
            INFO_COLOR = infoColor;
            return this;
        }

         
        public Config setSuccessColor(int successColor) {
            SUCCESS_COLOR = successColor;
            return this;
        }

         
        public Config setWarningColor(int warningColor) {
            WARNING_COLOR = warningColor;
            return this;
        }

         
        public Config setToastTypeface(Typeface typeface) {
            this.typeface = typeface;
            return this;
        }

         
        public Config setTextSize(int sizeInSp) {
            this.textSize = sizeInSp;
            return this;
        }

         
        public Config tintIcon(boolean tintIcon) {
            this.tintIcon = tintIcon;
            return this;
        }

        public void apply() {
            Toasty.DEFAULT_TEXT_COLOR = DEFAULT_TEXT_COLOR;
            Toasty.ERROR_COLOR = ERROR_COLOR;
            Toasty.INFO_COLOR = INFO_COLOR;
            Toasty.SUCCESS_COLOR = SUCCESS_COLOR;
            Toasty.WARNING_COLOR = WARNING_COLOR;
            Toasty.currentTypeface = typeface;
            Toasty.textSize = textSize;
            Toasty.tintIcon = tintIcon;
        }
    }
}
ObjectAnimator anim = ObjectAnimator.ofFloat(textView, "ScaleY", 0, 1);
anim.setInterpolator(new BounceInterpolator()); 
anim.setDuration(1000);
anim.start();
package com.kvft.bomba;



import android.content.ContentResolver;

import android.content.ContentUris;

import android.content.Context;

import android.database.Cursor;

import android.graphics.Bitmap;

import android.graphics.BitmapFactory;

import android.graphics.Canvas;

import android.graphics.ColorFilter;

import android.graphics.ColorMatrix;

import android.graphics.ColorMatrixColorFilter;

import android.graphics.LightingColorFilter;

import android.graphics.Matrix;

import android.graphics.Paint;

import android.graphics.PorterDuff;

import android.graphics.PorterDuffXfermode;

import android.graphics.Rect;

import android.graphics.RectF;

import android.media.ExifInterface;

import android.net.Uri;

import android.os.Environment;

import android.provider.DocumentsContract;

import android.provider.MediaStore;

import android.text.TextUtils;



import java.io.File;

import java.io.FileInputStream;

import java.io.FileOutputStream;

import java.io.FileReader;

import java.io.FileWriter;

import java.io.IOException;

import java.net.URLDecoder;

import java.text.SimpleDateFormat;

import java.util.ArrayList;

import java.util.Date;



public class FileUtil {



    private static void createNewFile(String path) {

        int lastSep = path.lastIndexOf(File.separator);

        if (lastSep > 0) {

            String dirPath = path.substring(0, lastSep);

            makeDir(dirPath);

        }



        File file = new File(path);



        try {

            if (!file.exists()) file.createNewFile();

        } catch (IOException e) {

            e.printStackTrace();

        }

    }



    public static String readFile(String path) {

        createNewFile(path);



        StringBuilder sb = new StringBuilder();

        FileReader fr = null;

        try {

            fr = new FileReader(new File(path));



            char[] buff = new char[1024];

            int length = 0;



            while ((length = fr.read(buff)) > 0) {

                sb.append(new String(buff, 0, length));

            }

        } catch (IOException e) {

            e.printStackTrace();

        } finally {

            if (fr != null) {

                try {

                    fr.close();

                } catch (Exception e) {

                    e.printStackTrace();

                }

            }

        }



        return sb.toString();

    }



    public static void writeFile(String path, String str) {

        createNewFile(path);

        FileWriter fileWriter = null;



        try {

            fileWriter = new FileWriter(new File(path), false);

            fileWriter.write(str);

            fileWriter.flush();

        } catch (IOException e) {

            e.printStackTrace();

        } finally {

            try {

                if (fileWriter != null)

                    fileWriter.close();

            } catch (IOException e) {

                e.printStackTrace();

            }

        }

    }



    public static void copyFile(String sourcePath, String destPath) {

        if (!isExistFile(sourcePath)) return;

        createNewFile(destPath);



        FileInputStream fis = null;

        FileOutputStream fos = null;



        try {

            fis = new FileInputStream(sourcePath);

            fos = new FileOutputStream(destPath, false);



            byte[] buff = new byte[1024];

            int length = 0;



            while ((length = fis.read(buff)) > 0) {

                fos.write(buff, 0, length);

            }

        } catch (IOException e) {

            e.printStackTrace();

        } finally {

            if (fis != null) {

                try {

                    fis.close();

                } catch (IOException e) {

                    e.printStackTrace();

                }

            }

            if (fos != null) {

                try {

                    fos.close();

                } catch (IOException e) {

                    e.printStackTrace();

                }

            }

        }

    }



    public static void copyDir(String oldPath, String newPath) {

        File oldFile = new File(oldPath);

        File[] files = oldFile.listFiles();

        File newFile = new File(newPath);

        if (!newFile.exists()) {

            newFile.mkdirs();

        }

        for (File file : files) {

            if (file.isFile()) {

                copyFile(file.getPath(), newPath + "/" + file.getName());

            } else if (file.isDirectory()) {

                copyDir(file.getPath(), newPath + "/" + file.getName());

            }

        }

    }



    public static void moveFile(String sourcePath, String destPath) {

        copyFile(sourcePath, destPath);

        deleteFile(sourcePath);

    }



    public static void deleteFile(String path) {

        File file = new File(path);



        if (!file.exists()) return;



        if (file.isFile()) {

            file.delete();

            return;

        }



        File[] fileArr = file.listFiles();



        if (fileArr != null) {

            for (File subFile : fileArr) {

                if (subFile.isDirectory()) {

                    deleteFile(subFile.getAbsolutePath());

                }



                if (subFile.isFile()) {

                    subFile.delete();

                }

            }

        }



        file.delete();

    }



    public static boolean isExistFile(String path) {

        File file = new File(path);

        return file.exists();

    }



    public static void makeDir(String path) {

        if (!isExistFile(path)) {

            File file = new File(path);

            file.mkdirs();

        }

    }



    public static void listDir(String path, ArrayList<String> list) {

        File dir = new File(path);

        if (!dir.exists() || dir.isFile()) return;



        File[] listFiles = dir.listFiles();

        if (listFiles == null || listFiles.length <= 0) return;



        if (list == null) return;

        list.clear();

        for (File file : listFiles) {

            list.add(file.getAbsolutePath());

        }

    }



    public static boolean isDirectory(String path) {

        if (!isExistFile(path)) return false;

        return new File(path).isDirectory();

    }



    public static boolean isFile(String path) {

        if (!isExistFile(path)) return false;

        return new File(path).isFile();

    }



    public static long getFileLength(String path) {

        if (!isExistFile(path)) return 0;

        return new File(path).length();

    }



    public static String getExternalStorageDir() {

        return Environment.getExternalStorageDirectory().getAbsolutePath();

    }



    public static String getPackageDataDir(Context context) {

        return context.getExternalFilesDir(null).getAbsolutePath();

    }



    public static String getPublicDir(String type) {

        return Environment.getExternalStoragePublicDirectory(type).getAbsolutePath();

    }



    public static String convertUriToFilePath(final Context context, final Uri uri) {

        String path = null;

        if (DocumentsContract.isDocumentUri(context, uri)) {

            if (isExternalStorageDocument(uri)) {

                final String docId = DocumentsContract.getDocumentId(uri);

                final String[] split = docId.split(":");

                final String type = split[0];



                if ("primary".equalsIgnoreCase(type)) {

                    path = Environment.getExternalStorageDirectory() + "/" + split[1];

                }

            } else if (isDownloadsDocument(uri)) {

                final String id = DocumentsContract.getDocumentId(uri);



                if (!TextUtils.isEmpty(id)) {

                    if (id.startsWith("raw:")) {

                        return id.replaceFirst("raw:", "");

                    }

                }



                final Uri contentUri = ContentUris

                        .withAppendedId(Uri.parse("content://downloads/public_downloads"), Long.valueOf(id));



                path = getDataColumn(context, contentUri, null, null);

            } else if (isMediaDocument(uri)) {

                final String docId = DocumentsContract.getDocumentId(uri);

                final String[] split = docId.split(":");

                final String type = split[0];



                Uri contentUri = null;

                if ("image".equals(type)) {

                    contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;

                } else if ("video".equals(type)) {

                    contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;

                } else if ("audio".equals(type)) {

                    contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;

                }



                final String selection = "_id=?";

                final String[] selectionArgs = new String[]{

                        split[1]

                };



                path = getDataColumn(context, contentUri, selection, selectionArgs);

            }

        } else if (ContentResolver.SCHEME_CONTENT.equalsIgnoreCase(uri.getScheme())) {

            path = getDataColumn(context, uri, null, null);

        } else if (ContentResolver.SCHEME_FILE.equalsIgnoreCase(uri.getScheme())) {

            path = uri.getPath();

        }



        if (path != null) {

            try {

                return URLDecoder.decode(path, "UTF-8");

            } catch(Exception e) {

                return null;

            }

        }

        return null;

    }



    private static String getDataColumn(Context context, Uri uri, String selection, String[] selectionArgs) {

        final String column = MediaStore.Images.Media.DATA;

        final String[] projection = {

                column

        };



        try (Cursor cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs, null)) {

            if (cursor != null && cursor.moveToFirst()) {

                final int column_index = cursor.getColumnIndexOrThrow(column);

                return cursor.getString(column_index);

            }

        } catch (Exception e) {



        }

        return null;

    }





    private static boolean isExternalStorageDocument(Uri uri) {

        return "com.android.externalstorage.documents".equals(uri.getAuthority());

    }



    private static boolean isDownloadsDocument(Uri uri) {

        return "com.android.providers.downloads.documents".equals(uri.getAuthority());

    }



    private static boolean isMediaDocument(Uri uri) {

        return "com.android.providers.media.documents".equals(uri.getAuthority());

    }



    private static void saveBitmap(Bitmap bitmap, String destPath) {

        FileUtil.createNewFile(destPath);

        try (FileOutputStream out = new FileOutputStream(new File(destPath))) {

            bitmap.compress(Bitmap.CompressFormat.PNG, 100, out);

        } catch (Exception e) {

            e.printStackTrace();

        }

    }



    public static Bitmap getScaledBitmap(String path, int max) {

        Bitmap src = BitmapFactory.decodeFile(path);



        int width = src.getWidth();

        int height = src.getHeight();

        float rate = 0.0f;



        if (width > height) {

            rate = max / (float) width;

            height = (int) (height * rate);

            width = max;

        } else {

            rate = max / (float) height;

            width = (int) (width * rate);

            height = max;

        }



        return Bitmap.createScaledBitmap(src, width, height, true);

    }



    public static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {

        final int width = options.outWidth;

        final int height = options.outHeight;

        int inSampleSize = 1;



        if (height > reqHeight || width > reqWidth) {

            final int halfHeight = height / 2;

            final int halfWidth = width / 2;



            while ((halfHeight / inSampleSize) >= reqHeight && (halfWidth / inSampleSize) >= reqWidth) {

                inSampleSize *= 2;

            }

        }



        return inSampleSize;

    }



    public static Bitmap decodeSampleBitmapFromPath(String path, int reqWidth, int reqHeight) {

        final BitmapFactory.Options options = new BitmapFactory.Options();

        options.inJustDecodeBounds = true;

        BitmapFactory.decodeFile(path, options);



        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);



        options.inJustDecodeBounds = false;

        return BitmapFactory.decodeFile(path, options);

    }



    public static void resizeBitmapFileRetainRatio(String fromPath, String destPath, int max) {

        if (!isExistFile(fromPath)) return;

        Bitmap bitmap = getScaledBitmap(fromPath, max);

        saveBitmap(bitmap, destPath);

    }



    public static void resizeBitmapFileToSquare(String fromPath, String destPath, int max) {

        if (!isExistFile(fromPath)) return;

        Bitmap src = BitmapFactory.decodeFile(fromPath);

        Bitmap bitmap = Bitmap.createScaledBitmap(src, max, max, true);

        saveBitmap(bitmap, destPath);

    }



    public static void resizeBitmapFileToCircle(String fromPath, String destPath) {

        if (!isExistFile(fromPath)) return;

        Bitmap src = BitmapFactory.decodeFile(fromPath);

        Bitmap bitmap = Bitmap.createBitmap(src.getWidth(),

                src.getHeight(), Bitmap.Config.ARGB_8888);

        Canvas canvas = new Canvas(bitmap);



        final int color = 0xff424242;

        final Paint paint = new Paint();

        final Rect rect = new Rect(0, 0, src.getWidth(), src.getHeight());



        paint.setAntiAlias(true);

        canvas.drawARGB(0, 0, 0, 0);

        paint.setColor(color);

        canvas.drawCircle(src.getWidth() / 2, src.getHeight() / 2,

                src.getWidth() / 2, paint);

        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));

        canvas.drawBitmap(src, rect, rect, paint);



        saveBitmap(bitmap, destPath);

    }



    public static void resizeBitmapFileWithRoundedBorder(String fromPath, String destPath, int pixels) {

        if (!isExistFile(fromPath)) return;

        Bitmap src = BitmapFactory.decodeFile(fromPath);

        Bitmap bitmap = Bitmap.createBitmap(src.getWidth(), src

                .getHeight(), Bitmap.Config.ARGB_8888);

        Canvas canvas = new Canvas(bitmap);



        final int color = 0xff424242;

        final Paint paint = new Paint();

        final Rect rect = new Rect(0, 0, src.getWidth(), src.getHeight());

        final RectF rectF = new RectF(rect);

        final float roundPx = pixels;



        paint.setAntiAlias(true);

        canvas.drawARGB(0, 0, 0, 0);

        paint.setColor(color);

        canvas.drawRoundRect(rectF, roundPx, roundPx, paint);



        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));

        canvas.drawBitmap(src, rect, rect, paint);



        saveBitmap(bitmap, destPath);

    }



    public static void cropBitmapFileFromCenter(String fromPath, String destPath, int w, int h) {

        if (!isExistFile(fromPath)) return;

        Bitmap src = BitmapFactory.decodeFile(fromPath);



        int width = src.getWidth();

        int height = src.getHeight();



        if (width < w && height < h) return;



        int x = 0;

        int y = 0;



        if (width > w) x = (width - w) / 2;



        if (height > h) y = (height - h) / 2;



        int cw = w;

        int ch = h;



        if (w > width) cw = width;



        if (h > height) ch = height;



        Bitmap bitmap = Bitmap.createBitmap(src, x, y, cw, ch);

        saveBitmap(bitmap, destPath);

    }



    public static void rotateBitmapFile(String fromPath, String destPath, float angle) {

        if (!isExistFile(fromPath)) return;

        Bitmap src = BitmapFactory.decodeFile(fromPath);

        Matrix matrix = new Matrix();

        matrix.postRotate(angle);

        Bitmap bitmap = Bitmap.createBitmap(src, 0, 0, src.getWidth(), src.getHeight(), matrix, true);

        saveBitmap(bitmap, destPath);

    }



    public static void scaleBitmapFile(String fromPath, String destPath, float x, float y) {

        if (!isExistFile(fromPath)) return;

        Bitmap src = BitmapFactory.decodeFile(fromPath);

        Matrix matrix = new Matrix();

        matrix.postScale(x, y);



        int w = src.getWidth();

        int h = src.getHeight();



        Bitmap bitmap = Bitmap.createBitmap(src, 0, 0, w, h, matrix, true);

        saveBitmap(bitmap, destPath);

    }



    public static void skewBitmapFile(String fromPath, String destPath, float x, float y) {

        if (!isExistFile(fromPath)) return;

        Bitmap src = BitmapFactory.decodeFile(fromPath);

        Matrix matrix = new Matrix();

        matrix.postSkew(x, y);



        int w = src.getWidth();

        int h = src.getHeight();



        Bitmap bitmap = Bitmap.createBitmap(src, 0, 0, w, h, matrix, true);

        saveBitmap(bitmap, destPath);

    }



    public static void setBitmapFileColorFilter(String fromPath, String destPath, int color) {

        if (!isExistFile(fromPath)) return;

        Bitmap src = BitmapFactory.decodeFile(fromPath);

        Bitmap bitmap = Bitmap.createBitmap(src, 0, 0,

                src.getWidth() - 1, src.getHeight() - 1);

        Paint p = new Paint();

        ColorFilter filter = new LightingColorFilter(color, 1);

        p.setColorFilter(filter);

        Canvas canvas = new Canvas(bitmap);

        canvas.drawBitmap(bitmap, 0, 0, p);

        saveBitmap(bitmap, destPath);

    }



    public static void setBitmapFileBrightness(String fromPath, String destPath, float brightness) {

        if (!isExistFile(fromPath)) return;

        Bitmap src = BitmapFactory.decodeFile(fromPath);

        ColorMatrix cm = new ColorMatrix(new float[]

                {

                        1, 0, 0, 0, brightness,

                        0, 1, 0, 0, brightness,

                        0, 0, 1, 0, brightness,

                        0, 0, 0, 1, 0

                });



        Bitmap bitmap = Bitmap.createBitmap(src.getWidth(), src.getHeight(), src.getConfig());

        Canvas canvas = new Canvas(bitmap);

        Paint paint = new Paint();

        paint.setColorFilter(new ColorMatrixColorFilter(cm));

        canvas.drawBitmap(src, 0, 0, paint);

        saveBitmap(bitmap, destPath);

    }



    public static void setBitmapFileContrast(String fromPath, String destPath, float contrast) {

        if (!isExistFile(fromPath)) return;

        Bitmap src = BitmapFactory.decodeFile(fromPath);

        ColorMatrix cm = new ColorMatrix(new float[]

                {

                        contrast, 0, 0, 0, 0,

                        0, contrast, 0, 0, 0,

                        0, 0, contrast, 0, 0,

                        0, 0, 0, 1, 0

                });



        Bitmap bitmap = Bitmap.createBitmap(src.getWidth(), src.getHeight(), src.getConfig());

        Canvas canvas = new Canvas(bitmap);

        Paint paint = new Paint();

        paint.setColorFilter(new ColorMatrixColorFilter(cm));

        canvas.drawBitmap(src, 0, 0, paint);



        saveBitmap(bitmap, destPath);

    }



    public static int getJpegRotate(String filePath) {

        int rotate = 0;

        try {

            ExifInterface exif = new ExifInterface(filePath);

            int iOrientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, -1);



            switch (iOrientation) {

                case ExifInterface.ORIENTATION_ROTATE_90:

                    rotate = 90;

                    break;



                case ExifInterface.ORIENTATION_ROTATE_180:

                    rotate = 180;

                    break;



                case ExifInterface.ORIENTATION_ROTATE_270:

                    rotate = 270;

                    break;

            }

        } catch (IOException e) {

            return 0;

        }



        return rotate;

    }



    public static File createNewPictureFile(Context context) {

        SimpleDateFormat date = new SimpleDateFormat("yyyyMMdd_HHmmss");

        String fileName = date.format(new Date()) + ".jpg";

        return new File(context.getExternalFilesDir(Environment.DIRECTORY_DCIM).getAbsolutePath() + File.separator + fileName);

    }
  
}
static class UiUtil {
    UiUtil() {
    }
    static int dp(Context context, int val) {
        return (int) TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_DIP, val, context.getResources().getDisplayMetrics());
    }
    static int sp(Context context, int val) {
        return (int) TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_SP, val, context.getResources().getDisplayMetrics());
    }
    static int themeIntAttr(Context context, String attr) {
        final android.content.res.Resources.Theme theme = context.getTheme();
        if (theme == null) {
            return -1;
        }
        final TypedValue value = new TypedValue();
        final int id = context.getResources().getIdentifier(attr, "attr", context.getPackageName());

        if (id == 0) {
            // Not found
            return -1;
        }
        theme.resolveAttribute(id, value, true);
        return value.data;
    }
    static int setAlpha(int argb, float alpha) {
        if (alpha > 1.0f) {
            alpha = 1.0f;
        } else if (alpha <= 0.0f) {
            alpha = 0.0f;
        }
        return ((int) ((argb >>> 24) * alpha) << 24) | (argb & 0x00FFFFFF);
    }
}
static class FloatValueAnimatorBuilder {

    private final ValueAnimator animator;

    private EndListener endListener;

    interface UpdateListener {
        void onUpdate(float lerpTime);
    }
    interface EndListener {
        void onEnd();
    }
    protected FloatValueAnimatorBuilder() {
        this(false);
    }
    FloatValueAnimatorBuilder(boolean reverse) {
        if (reverse) {
            this.animator = ValueAnimator.ofFloat(1.0f, 0.0f);
        } else {
            this.animator = ValueAnimator.ofFloat(0.0f, 1.0f);
        }
    }
    public FloatValueAnimatorBuilder delayBy(long millis) {
        animator.setStartDelay(millis);
        return this;
    }
    public FloatValueAnimatorBuilder duration(long millis) {
        animator.setDuration(millis);
        return this;
    }
    public FloatValueAnimatorBuilder interpolator(TimeInterpolator lerper) {
        animator.setInterpolator(lerper);
        return this;
    }
    public FloatValueAnimatorBuilder repeat(int times) {
        animator.setRepeatCount(times);
        return this;
    }
    public FloatValueAnimatorBuilder onUpdate(final UpdateListener listener) {
        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator animation) {
                listener.onUpdate((float) animation.getAnimatedValue());
            }
        });
        return this;
    }
    public FloatValueAnimatorBuilder onEnd(final EndListener listener) {
        this.endListener = listener;
        return this;
    }
    public ValueAnimator build() {
        if (endListener != null) {
            animator.addListener(new AnimatorListenerAdapter() {
                @Override
                public void onAnimationEnd(Animator animation) {
                    endListener.onEnd();
                }
            });
        }
        return animator;
    }
}
static class ReflectUtil {
    ReflectUtil() {
    }
    static Object getPrivateField(Object source, String fieldName)
            throws NoSuchFieldException, IllegalAccessException {
        final java.lang.reflect.Field objectField = source.getClass().getDeclaredField(fieldName);
        objectField.setAccessible(true);
        return objectField.get(source);
    }
}

static class TapTarget extends Activity {
    final CharSequence title;
    final CharSequence description;
    float outerCircleAlpha = 0.96f;
    int targetRadius = 44;
    Rect bounds;
    android.graphics.drawable.Drawable icon;
    Typeface titleTypeface;
    Typeface descriptionTypeface;


    private int outerCircleColorRes = -1;
    private int targetCircleColorRes = -1;
    private int dimColorRes = -1;
    private int titleTextColorRes = -1;
    private int descriptionTextColorRes = -1;

    private Integer outerCircleColor = null;
    private Integer targetCircleColor = null;
    private Integer dimColor = null;
    private Integer titleTextColor = null;
    private Integer descriptionTextColor = null;

    private int titleTextDimen = -1;
    private int descriptionTextDimen = -1;
    private int titleTextSize = 20;
    private int descriptionTextSize = 18;
    int id = -1;
    boolean drawShadow = false;
    boolean cancelable = true;
    boolean tintTarget = true;
    boolean transparentTarget = false;
    float descriptionTextAlpha = 0.54f;

    public static TapTarget forView(View view, CharSequence title) {
        return forView(view, title, null);
    }
    public static TapTarget forView(View view, CharSequence title, CharSequence description) {
        return new ViewTapTarget(view, title, description);
    }
    public static TapTarget forBounds(Rect bounds, CharSequence title) {
        return forBounds(bounds, title, null);
    }
    public static TapTarget forBounds(Rect bounds, CharSequence title,  CharSequence description) {
        return new TapTarget(bounds, title, description);
    }
    protected TapTarget(Rect bounds, CharSequence title,  CharSequence description) {
        this(title, description);
        if (bounds == null) {
            throw new IllegalArgumentException("Cannot pass null bounds or title");
        }
        this.bounds = bounds;
    }
    protected TapTarget(CharSequence title,  CharSequence description) {
        if (title == null) {
            throw new IllegalArgumentException("Cannot pass null title");
        }
        this.title = title;
        this.description = description;
    }
    public TapTarget transparentTarget(boolean transparent) {
        this.transparentTarget = transparent;
        return this;
    }
    public TapTarget outerCircleColor( int color) {
        this.outerCircleColorRes = color;
        return this;
    }
    public TapTarget outerCircleColorInt( int color) {
        this.outerCircleColor = color;
        return this;
    }
    public TapTarget outerCircleAlpha(float alpha) {
        if (alpha < 0.0f || alpha > 1.0f) {
            throw new IllegalArgumentException("Given an invalid alpha value: " + alpha);
        }
        this.outerCircleAlpha = alpha;
        return this;
    }
    public TapTarget targetCircleColor( int color) {
        this.targetCircleColorRes = color;
        return this;
    }
    public TapTarget targetCircleColorInt( int color) {
        this.targetCircleColor = color;
        return this;
    }
    public TapTarget textColor( int color) {
        this.titleTextColorRes = color;
        this.descriptionTextColorRes = color;
        return this;
    }
    public TapTarget textColorInt( int color) {
        this.titleTextColor = color;
        this.descriptionTextColor = color;
        return this;
    }
    public TapTarget titleTextColor( int color) {
        this.titleTextColorRes = color;
        return this;
    }
    public TapTarget titleTextColorInt( int color) {
        this.titleTextColor = color;
        return this;
    }
    public TapTarget descriptionTextColor( int color) {
        this.descriptionTextColorRes = color;
        return this;
    }
    public TapTarget descriptionTextColorInt( int color) {
        this.descriptionTextColor = color;
        return this;
    }
    public TapTarget textTypeface(Typeface typeface) {
        if (typeface == null) throw new IllegalArgumentException("Cannot use a null typeface");
        titleTypeface = typeface;
        descriptionTypeface = typeface;
        return this;
    }
    public TapTarget titleTypeface(Typeface titleTypeface) {
        if (titleTypeface == null) throw new IllegalArgumentException("Cannot use a null typeface");
        this.titleTypeface = titleTypeface;
        return this;
    }
    public TapTarget descriptionTypeface(Typeface descriptionTypeface) {
        if (descriptionTypeface == null) throw new IllegalArgumentException("Cannot use a null typeface");
        this.descriptionTypeface = descriptionTypeface;
        return this;
    }
    public TapTarget titleTextSize(int sp) {
        if (sp < 0) throw new IllegalArgumentException("Given negative text size");
        this.titleTextSize = sp;
        return this;
    }
    public TapTarget descriptionTextSize(int sp) {
        if (sp < 0) throw new IllegalArgumentException("Given negative text size");
        this.descriptionTextSize = sp;
        return this;
    }
    public TapTarget titleTextDimen( int dimen) {
        this.titleTextDimen = dimen;
        return this;
    }
    public TapTarget descriptionTextAlpha(float descriptionTextAlpha) {
        if (descriptionTextAlpha < 0 || descriptionTextAlpha > 1f) {
            throw new IllegalArgumentException("Given an invalid alpha value: " + descriptionTextAlpha);
        }
        this.descriptionTextAlpha = descriptionTextAlpha;
        return this;
    }
    public TapTarget descriptionTextDimen( int dimen) {
        this.descriptionTextDimen = dimen;
        return this;
    }
    public TapTarget dimColor( int color) {
        this.dimColorRes = color;
        return this;
    }
    public TapTarget dimColorInt( int color) {
        this.dimColor = color;
        return this;
    }
    public TapTarget drawShadow(boolean draw) {
        this.drawShadow = draw;
        return this;
    }
    public TapTarget cancelable(boolean status) {
        this.cancelable = status;
        return this;
    }
    public TapTarget tintTarget(boolean tint) {
        this.tintTarget = tint;
        return this;
    }
    public TapTarget icon(android.graphics.drawable.Drawable icon) {
        return icon(icon, false);
    }
    public TapTarget icon(android.graphics.drawable.Drawable icon, boolean hasSetBounds) {
        if (icon == null) throw new IllegalArgumentException("Cannot use null drawable");
        this.icon = icon;
        if (!hasSetBounds) {
            this.icon.setBounds(new Rect(0, 0, this.icon.getIntrinsicWidth(), this.icon.getIntrinsicHeight()));
        }
        return this;
    }
    public TapTarget id(int id) {
        this.id = id;
        return this;
    }
    public TapTarget targetRadius(int targetRadius) {
        this.targetRadius = targetRadius;
        return this;
    }
    public int id() {
        return id;
    }
    public void onReady(Runnable runnable) {
        runnable.run();
    }
    public Rect bounds() {
        if (bounds == null) {
            throw new IllegalStateException("Requesting bounds that are not set! Make sure your target is ready");
        }
        return bounds;
    }
    Integer outerCircleColorInt(Context context) {
        return colorResOrInt(context, outerCircleColor, outerCircleColorRes);
    }
    Integer targetCircleColorInt(Context context) {
        return colorResOrInt(context, targetCircleColor, targetCircleColorRes);
    }
    Integer dimColorInt(Context context) {
        return colorResOrInt(context, dimColor, dimColorRes);
    }
    Integer titleTextColorInt(Context context) {
        return colorResOrInt(context, titleTextColor, titleTextColorRes);
    }

    Integer descriptionTextColorInt(Context context) {
        return colorResOrInt(context, descriptionTextColor, descriptionTextColorRes);
    }
    int titleTextSizePx(Context context) {
        return dimenOrSize(context, titleTextSize, titleTextDimen);
    }
    int descriptionTextSizePx(Context context) {
        return dimenOrSize(context, descriptionTextSize, descriptionTextDimen);
    }

    private Integer colorResOrInt(Context context, Integer value,  int resource) {
        if (resource != -1) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                return context.getColor(resource);
            }
        }
        return value;
    }
    private int dimenOrSize(Context context, int size,  int dimen) {
        if (dimen != -1) {
            return context.getResources().getDimensionPixelSize(dimen);
        }
        return UiUtil.sp(context, size);
    }
}
static class TapTargetView extends View {
    private boolean isDismissed = false;
    private boolean isDismissing = false;
    private boolean isInteractable = true;

    final int TARGET_PADDING;
    final int TARGET_RADIUS;
    final int TARGET_PULSE_RADIUS;
    final int TEXT_PADDING;
    final int TEXT_SPACING;
    final int TEXT_MAX_WIDTH;
    final int TEXT_POSITIONING_BIAS;
    final int CIRCLE_PADDING;
    final int GUTTER_DIM;
    final int SHADOW_DIM;
    final int SHADOW_JITTER_DIM;


    final ViewGroup boundingParent;
    final ViewManager parent;
    final TapTarget target;
    final Rect targetBounds;

    final TextPaint titlePaint;
    final TextPaint descriptionPaint;
    final Paint outerCirclePaint;
    final Paint outerCircleShadowPaint;
    final Paint targetCirclePaint;
    final Paint targetCirclePulsePaint;

    CharSequence title;

    StaticLayout titleLayout;

    CharSequence description;

    StaticLayout descriptionLayout;
    boolean isDark;
    boolean debug;
    boolean shouldTintTarget;
    boolean shouldDrawShadow;
    boolean cancelable;
    boolean visible;

    // Debug related variables

    SpannableStringBuilder debugStringBuilder;

    DynamicLayout debugLayout;

    TextPaint debugTextPaint;

    Paint debugPaint;

    // Drawing properties
    Rect drawingBounds;
    Rect textBounds;

    Path outerCirclePath;
    float outerCircleRadius;
    int calculatedOuterCircleRadius;
    int[] outerCircleCenter;
    int outerCircleAlpha;

    float targetCirclePulseRadius;
    int targetCirclePulseAlpha;

    float targetCircleRadius;
    int targetCircleAlpha;

    int textAlpha;
    int dimColor;

    float lastTouchX;
    float lastTouchY;

    int topBoundary;
    int bottomBoundary;

    Bitmap tintedTarget;

    Listener listener;


    ViewOutlineProvider outlineProvider;

    public static TapTargetView showFor(Activity activity, TapTarget target) {
        return showFor(activity, target, null);
    }

    public static TapTargetView showFor(Activity activity, TapTarget target, Listener listener) {
        if (activity == null) throw new IllegalArgumentException("Activity is null");

        final ViewGroup decor = (ViewGroup) activity.getWindow().getDecorView();
        final ViewGroup.LayoutParams layoutParams = new ViewGroup.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
        final ViewGroup content = (ViewGroup) decor.findViewById(android.R.id.content);
        final TapTargetView tapTargetView = new TapTargetView(activity, decor, content, target, listener);
        decor.addView(tapTargetView, layoutParams);

        return tapTargetView;
    }

    public static TapTargetView showFor(Dialog dialog, TapTarget target) {
        return showFor(dialog, target, null);
    }

    public static TapTargetView showFor(Dialog dialog, TapTarget target, Listener listener) {
        if (dialog == null) throw new IllegalArgumentException("Dialog is null");

        final Context context = dialog.getContext();
        final WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
        final WindowManager.LayoutParams params = new WindowManager.LayoutParams();
        params.type = WindowManager.LayoutParams.TYPE_APPLICATION;
        params.format = PixelFormat.RGBA_8888;
        params.flags = 0;
        params.gravity = Gravity.START | Gravity.TOP;
        params.x = 0;
        params.y = 0;
        params.width = WindowManager.LayoutParams.MATCH_PARENT;
        params.height = WindowManager.LayoutParams.MATCH_PARENT;

        final TapTargetView tapTargetView = new TapTargetView(context, windowManager, null, target, listener);
        windowManager.addView(tapTargetView, params);

        return tapTargetView;
    }

    public static class Listener {
        /** Signals that the user has clicked inside of the target **/
        public void onTargetClick(TapTargetView view) {
            view.dismiss(true);
        }

        /** Signals that the user has long clicked inside of the target **/
        public void onTargetLongClick(TapTargetView view) {
            onTargetClick(view);
        }

        /** If cancelable, signals that the user has clicked outside of the outer circle **/
        public void onTargetCancel(TapTargetView view) {
            view.dismiss(false);
        }

        /** Signals that the user clicked on the outer circle portion of the tap target **/
        public void onOuterCircleClick(TapTargetView view) {
            // no-op as default
        }

        /**
         * Signals that the tap target has been dismissed
         * @param userInitiated Whether the user caused this action
         *
         *
         */
        public void onTargetDismissed(TapTargetView view, boolean userInitiated) {
        }
    }

    final FloatValueAnimatorBuilder.UpdateListener expandContractUpdateListener = new FloatValueAnimatorBuilder.UpdateListener() {
        @Override
        public void onUpdate(float lerpTime) {
            final float newOuterCircleRadius = calculatedOuterCircleRadius * lerpTime;
            final boolean expanding = newOuterCircleRadius > outerCircleRadius;
            if (!expanding) {
                // When contracting we need to invalidate the old drawing bounds. Otherwise
                // you will see artifacts as the circle gets smaller
                calculateDrawingBounds();
            }

            final float targetAlpha = target.outerCircleAlpha * 255;
            outerCircleRadius = newOuterCircleRadius;
            outerCircleAlpha = (int) Math.min(targetAlpha, (lerpTime * 1.5f * targetAlpha));
            outerCirclePath.reset();
            outerCirclePath.addCircle(outerCircleCenter[0], outerCircleCenter[1], outerCircleRadius, Path.Direction.CW);

            targetCircleAlpha = (int) Math.min(255.0f, (lerpTime * 1.5f * 255.0f));

            if (expanding) {
                targetCircleRadius = TARGET_RADIUS * Math.min(1.0f, lerpTime * 1.5f);
            } else {
                targetCircleRadius = TARGET_RADIUS * lerpTime;
                targetCirclePulseRadius *= lerpTime;
            }

            textAlpha = (int) (delayedLerp(lerpTime, 0.7f) * 255);

            if (expanding) {
                calculateDrawingBounds();
            }

            invalidateViewAndOutline(drawingBounds);
        }
    };

    final ValueAnimator expandAnimation = new FloatValueAnimatorBuilder()
            .duration(250)
            .delayBy(250)
            .interpolator(new AccelerateDecelerateInterpolator())
            .onUpdate(new FloatValueAnimatorBuilder.UpdateListener() {
                @Override
                public void onUpdate(float lerpTime) {
                    expandContractUpdateListener.onUpdate(lerpTime);
                }
            })
            .onEnd(new FloatValueAnimatorBuilder.EndListener() {
                @Override
                public void onEnd() {
                    pulseAnimation.start();
                    isInteractable = true;
                }
            })
            .build();

    final ValueAnimator pulseAnimation = new FloatValueAnimatorBuilder()
            .duration(1000)
            .repeat(ValueAnimator.INFINITE)
            .interpolator(new AccelerateDecelerateInterpolator())
            .onUpdate(new FloatValueAnimatorBuilder.UpdateListener() {
                @Override
                public void onUpdate(float lerpTime) {
                    final float pulseLerp = delayedLerp(lerpTime, 0.5f);
                    targetCirclePulseRadius = (1.0f + pulseLerp) * TARGET_RADIUS;
                    targetCirclePulseAlpha = (int) ((1.0f - pulseLerp) * 255);
                    targetCircleRadius = TARGET_RADIUS + halfwayLerp(lerpTime) * TARGET_PULSE_RADIUS;

                    if (outerCircleRadius != calculatedOuterCircleRadius) {
                        outerCircleRadius = calculatedOuterCircleRadius;
                    }

                    calculateDrawingBounds();
                    invalidateViewAndOutline(drawingBounds);
                }
            })
            .build();

    final ValueAnimator dismissAnimation = new FloatValueAnimatorBuilder(true)
            .duration(250)
            .interpolator(new AccelerateDecelerateInterpolator())
            .onUpdate(new FloatValueAnimatorBuilder.UpdateListener() {
                @Override
                public void onUpdate(float lerpTime) {
                    expandContractUpdateListener.onUpdate(lerpTime);
                }
            })
            .onEnd(new FloatValueAnimatorBuilder.EndListener() {
                @Override
                public void onEnd() {
                    onDismiss(true);
                    ViewUtil.removeView(parent, TapTargetView.this);
                }
            })
            .build();

    private final ValueAnimator dismissConfirmAnimation = new FloatValueAnimatorBuilder()
            .duration(250)
            .interpolator(new AccelerateDecelerateInterpolator())
            .onUpdate(new FloatValueAnimatorBuilder.UpdateListener() {
                @Override
                public void onUpdate(float lerpTime) {
                    final float spedUpLerp = Math.min(1.0f, lerpTime * 2.0f);
                    outerCircleRadius = calculatedOuterCircleRadius * (1.0f + (spedUpLerp * 0.2f));
                    outerCircleAlpha = (int) ((1.0f - spedUpLerp) * target.outerCircleAlpha * 255.0f);
                    outerCirclePath.reset();
                    outerCirclePath.addCircle(outerCircleCenter[0], outerCircleCenter[1], outerCircleRadius, Path.Direction.CW);
                    targetCircleRadius = (1.0f - lerpTime) * TARGET_RADIUS;
                    targetCircleAlpha = (int) ((1.0f - lerpTime) * 255.0f);
                    targetCirclePulseRadius = (1.0f + lerpTime) * TARGET_RADIUS;
                    targetCirclePulseAlpha = (int) ((1.0f - lerpTime) * targetCirclePulseAlpha);
                    textAlpha = (int) ((1.0f - spedUpLerp) * 255.0f);
                    calculateDrawingBounds();
                    invalidateViewAndOutline(drawingBounds);
                }
            })
            .onEnd(new FloatValueAnimatorBuilder.EndListener() {
                @Override
                public void onEnd() {
                    onDismiss(true);
                    ViewUtil.removeView(parent, TapTargetView.this);
                }
            })
            .build();

    private ValueAnimator[] animators = new ValueAnimator[]
            {expandAnimation, pulseAnimation, dismissConfirmAnimation, dismissAnimation};

    private final ViewTreeObserver.OnGlobalLayoutListener globalLayoutListener;
    public TapTargetView(final Context context,
                         final ViewManager parent,
                          final ViewGroup boundingParent,
                         final TapTarget target,
                          final Listener userListener) {
        super(context);
        if (target == null) throw new IllegalArgumentException("Target cannot be null");

        this.target = target;
        this.parent = parent;
        this.boundingParent = boundingParent;
        this.listener = userListener != null ? userListener : new Listener();
        this.title = target.title;
        this.description = target.description;

        TARGET_PADDING = UiUtil.dp(context, 20);
        CIRCLE_PADDING = UiUtil.dp(context, 40);
        TARGET_RADIUS = UiUtil.dp(context, target.targetRadius);
        TEXT_PADDING = UiUtil.dp(context, 40);
        TEXT_SPACING = UiUtil.dp(context, 8);
        TEXT_MAX_WIDTH = UiUtil.dp(context, 360);
        TEXT_POSITIONING_BIAS = UiUtil.dp(context, 20);
        GUTTER_DIM = UiUtil.dp(context, 88);
        SHADOW_DIM = UiUtil.dp(context, 8);
        SHADOW_JITTER_DIM = UiUtil.dp(context, 1);
        TARGET_PULSE_RADIUS = (int) (0.1f * TARGET_RADIUS);

        outerCirclePath = new Path();
        targetBounds = new Rect();
        drawingBounds = new Rect();

        titlePaint = new TextPaint();
        titlePaint.setTextSize(target.titleTextSizePx(context));
        titlePaint.setTypeface(Typeface.create("sans-serif-medium", Typeface.NORMAL));
        titlePaint.setAntiAlias(true);

        descriptionPaint = new TextPaint();
        descriptionPaint.setTextSize(target.descriptionTextSizePx(context));
        descriptionPaint.setTypeface(Typeface.create(Typeface.SANS_SERIF, Typeface.NORMAL));
        descriptionPaint.setAntiAlias(true);
        descriptionPaint.setAlpha((int) (0.54f * 255.0f));

        outerCirclePaint = new Paint();
        outerCirclePaint.setAntiAlias(true);
        outerCirclePaint.setAlpha((int) (target.outerCircleAlpha * 255.0f));

        outerCircleShadowPaint = new Paint();
        outerCircleShadowPaint.setAntiAlias(true);
        outerCircleShadowPaint.setAlpha(50);
        outerCircleShadowPaint.setStyle(Paint.Style.STROKE);
        outerCircleShadowPaint.setStrokeWidth(SHADOW_JITTER_DIM);
        outerCircleShadowPaint.setColor(Color.BLACK);

        targetCirclePaint = new Paint();
        targetCirclePaint.setAntiAlias(true);

        targetCirclePulsePaint = new Paint();
        targetCirclePulsePaint.setAntiAlias(true);

        applyTargetOptions(context);

        globalLayoutListener = new ViewTreeObserver.OnGlobalLayoutListener() {
            @Override
            public void onGlobalLayout() {
                if (isDismissing) {
                    return;
                }
                updateTextLayouts();
                target.onReady(new Runnable() {
                    @Override
                    public void run() {
                        final int[] offset = new int[2];

                        targetBounds.set(target.bounds());

                        getLocationOnScreen(offset);
                        targetBounds.offset(-offset[0], -offset[1]);

                        if (boundingParent != null) {
                            final WindowManager windowManager
                                    = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
                            final DisplayMetrics displayMetrics = new DisplayMetrics();
                            windowManager.getDefaultDisplay().getMetrics(displayMetrics);

                            final Rect rect = new Rect();
                            boundingParent.getWindowVisibleDisplayFrame(rect);

                            // We bound the boundaries to be within the screen's coordinates to
                            // handle the case where the layout bounds do not match
                            // (like when FLAG_LAYOUT_NO_LIMITS is specified)
                            topBoundary = Math.max(0, rect.top);
                            bottomBoundary = Math.min(rect.bottom, displayMetrics.heightPixels);
                        }

                        drawTintedTarget();
                        requestFocus();
                        calculateDimensions();

                        startExpandAnimation();
                    }
                });
            }
        };

        getViewTreeObserver().addOnGlobalLayoutListener(globalLayoutListener);

        setFocusableInTouchMode(true);
        setClickable(true);
        setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                if (listener == null || outerCircleCenter == null || !isInteractable) return;

                final boolean clickedInTarget =
                        distance(targetBounds.centerX(), targetBounds.centerY(), (int) lastTouchX, (int) lastTouchY) <= targetCircleRadius;
                final double distanceToOuterCircleCenter = distance(outerCircleCenter[0], outerCircleCenter[1],
                        (int) lastTouchX, (int) lastTouchY);
                final boolean clickedInsideOfOuterCircle = distanceToOuterCircleCenter <= outerCircleRadius;

                if (clickedInTarget) {
                    isInteractable = false;
                    listener.onTargetClick(TapTargetView.this);
                } else if (clickedInsideOfOuterCircle) {
                    listener.onOuterCircleClick(TapTargetView.this);
                } else if (cancelable) {
                    isInteractable = false;
                    listener.onTargetCancel(TapTargetView.this);
                }
            }
        });

        setOnLongClickListener(new OnLongClickListener() {
            @Override
            public boolean onLongClick(View v) {
                if (listener == null) return false;

                if (targetBounds.contains((int) lastTouchX, (int) lastTouchY)) {
                    listener.onTargetLongClick(TapTargetView.this);
                    return true;
                }

                return false;
            }
        });
    }

    private void startExpandAnimation() {
        if (!visible) {
            isInteractable = false;
            expandAnimation.start();
            visible = true;
        }
    }

    protected void applyTargetOptions(Context context) {
        shouldTintTarget = target.tintTarget;
        shouldDrawShadow = target.drawShadow;
        cancelable = target.cancelable;

        // We can't clip out portions of a view outline, so if the user specified a transparent
        // target, we need to fallback to drawing a jittered shadow approximation
        if (shouldDrawShadow && Build.VERSION.SDK_INT >= 21 && !target.transparentTarget) {
            outlineProvider = new ViewOutlineProvider() {
                @Override
                public void getOutline(View view, Outline outline) {
                    if (outerCircleCenter == null) return;
                    outline.setOval(
                            (int) (outerCircleCenter[0] - outerCircleRadius), (int) (outerCircleCenter[1] - outerCircleRadius),
                            (int) (outerCircleCenter[0] + outerCircleRadius), (int) (outerCircleCenter[1] + outerCircleRadius));
                    outline.setAlpha(outerCircleAlpha / 255.0f);
                    if (Build.VERSION.SDK_INT >= 22) {
                        outline.offset(0, SHADOW_DIM);
                    }
                }
            };

            setOutlineProvider(outlineProvider);
            setElevation(SHADOW_DIM);
        }

        if (shouldDrawShadow && outlineProvider == null && Build.VERSION.SDK_INT < 18) {
            setLayerType(LAYER_TYPE_SOFTWARE, null);
        } else {
            setLayerType(LAYER_TYPE_HARDWARE, null);
        }

        final android.content.res.Resources.Theme theme = context.getTheme();
        isDark = UiUtil.themeIntAttr(context, "isLightTheme") == 0;

        final Integer outerCircleColor = target.outerCircleColorInt(context);
        if (outerCircleColor != null) {
            outerCirclePaint.setColor(outerCircleColor);
        } else if (theme != null) {
            outerCirclePaint.setColor(UiUtil.themeIntAttr(context, "colorPrimary"));
        } else {
            outerCirclePaint.setColor(Color.WHITE);
        }

        final Integer targetCircleColor = target.targetCircleColorInt(context);
        if (targetCircleColor != null) {
            targetCirclePaint.setColor(targetCircleColor);
        } else {
            targetCirclePaint.setColor(isDark ? Color.BLACK : Color.WHITE);
        }

        if (target.transparentTarget) {
            targetCirclePaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));
        }

        targetCirclePulsePaint.setColor(targetCirclePaint.getColor());

        final Integer targetDimColor = target.dimColorInt(context);
        if (targetDimColor != null) {
            dimColor = UiUtil.setAlpha(targetDimColor, 0.3f);
        } else {
            dimColor = -1;
        }

        final Integer titleTextColor = target.titleTextColorInt(context);
        if (titleTextColor != null) {
            titlePaint.setColor(titleTextColor);
        } else {
            titlePaint.setColor(isDark ? Color.BLACK : Color.WHITE);
        }

        final Integer descriptionTextColor = target.descriptionTextColorInt(context);
        if (descriptionTextColor != null) {
            descriptionPaint.setColor(descriptionTextColor);
        } else {
            descriptionPaint.setColor(titlePaint.getColor());
        }

        if (target.titleTypeface != null) {
            titlePaint.setTypeface(target.titleTypeface);
        }

        if (target.descriptionTypeface != null) {
            descriptionPaint.setTypeface(target.descriptionTypeface);
        }
    }

    @Override
    protected void onDetachedFromWindow() {
        super.onDetachedFromWindow();
        onDismiss(false);
    }

    void onDismiss(boolean userInitiated) {
        if (isDismissed) return;

        isDismissing = false;
        isDismissed = true;

        for (final ValueAnimator animator : animators) {
            animator.cancel();
            animator.removeAllUpdateListeners();
        }
        ViewUtil.removeOnGlobalLayoutListener(getViewTreeObserver(), globalLayoutListener);
        visible = false;

        if (listener != null) {
            listener.onTargetDismissed(this, userInitiated);
        }
    }

    @Override
    protected void onDraw(Canvas c) {
        if (isDismissed || outerCircleCenter == null) return;

        if (topBoundary > 0 && bottomBoundary > 0) {
            c.clipRect(0, topBoundary, getWidth(), bottomBoundary);
        }

        if (dimColor != -1) {
            c.drawColor(dimColor);
        }

        int saveCount;
        outerCirclePaint.setAlpha(outerCircleAlpha);
        if (shouldDrawShadow && outlineProvider == null) {
            saveCount = c.save();
            {
                c.clipPath(outerCirclePath, Region.Op.DIFFERENCE);
                drawJitteredShadow(c);
            }
            c.restoreToCount(saveCount);
        }
        c.drawCircle(outerCircleCenter[0], outerCircleCenter[1], outerCircleRadius, outerCirclePaint);

        targetCirclePaint.setAlpha(targetCircleAlpha);
        if (targetCirclePulseAlpha > 0) {
            targetCirclePulsePaint.setAlpha(targetCirclePulseAlpha);
            c.drawCircle(targetBounds.centerX(), targetBounds.centerY(),
                    targetCirclePulseRadius, targetCirclePulsePaint);
        }
        c.drawCircle(targetBounds.centerX(), targetBounds.centerY(),
                targetCircleRadius, targetCirclePaint);

        saveCount = c.save();
        {
            c.translate(textBounds.left, textBounds.top);
            titlePaint.setAlpha(textAlpha);
            if (titleLayout != null) {
                titleLayout.draw(c);
            }

            if (descriptionLayout != null && titleLayout != null) {
                c.translate(0, titleLayout.getHeight() + TEXT_SPACING);
                descriptionPaint.setAlpha((int) (target.descriptionTextAlpha * textAlpha));
                descriptionLayout.draw(c);
            }
        }
        c.restoreToCount(saveCount);

        saveCount = c.save();
        {
            if (tintedTarget != null) {
                c.translate(targetBounds.centerX() - tintedTarget.getWidth() / 2,
                        targetBounds.centerY() - tintedTarget.getHeight() / 2);
                c.drawBitmap(tintedTarget, 0, 0, targetCirclePaint);
            } else if (target.icon != null) {
                c.translate(targetBounds.centerX() - target.icon.getBounds().width() / 2,
                        targetBounds.centerY() - target.icon.getBounds().height() / 2);
                target.icon.setAlpha(targetCirclePaint.getAlpha());
                target.icon.draw(c);
            }
        }
        c.restoreToCount(saveCount);

        if (debug) {
            drawDebugInformation(c);
        }
    }

    @Override
    public boolean onTouchEvent(MotionEvent e) {
        lastTouchX = e.getX();
        lastTouchY = e.getY();
        return super.onTouchEvent(e);
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (isVisible() && cancelable && keyCode == KeyEvent.KEYCODE_BACK) {
            event.startTracking();
            return true;
        }

        return false;
    }

    @Override
    public boolean onKeyUp(int keyCode, KeyEvent event) {
        if (isVisible() && isInteractable && cancelable
                && keyCode == KeyEvent.KEYCODE_BACK && event.isTracking() && !event.isCanceled()) {
            isInteractable = false;

            if (listener != null) {
                listener.onTargetCancel(this);
            } else {
                new Listener().onTargetCancel(this);
            }

            return true;
        }

        return false;
    }

    /**
     * Dismiss this view
     * @param tappedTarget If the user tapped the target or not
     *                     (results in different dismiss animations)
     */
    public void dismiss(boolean tappedTarget) {
        isDismissing = true;
        pulseAnimation.cancel();
        expandAnimation.cancel();
        if (tappedTarget) {
            dismissConfirmAnimation.start();
        } else {
            dismissAnimation.start();
        }
    }

    /** Specify whether to draw a wireframe around the view, useful for debugging **/
    public void setDrawDebug(boolean status) {
        if (debug != status) {
            debug = status;
            postInvalidate();
        }
    }

    /** Returns whether this view is visible or not **/
    public boolean isVisible() {
        return !isDismissed && visible;
    }

    void drawJitteredShadow(Canvas c) {
        final float baseAlpha = 0.20f * outerCircleAlpha;
        outerCircleShadowPaint.setStyle(Paint.Style.FILL_AND_STROKE);
        outerCircleShadowPaint.setAlpha((int) baseAlpha);
        c.drawCircle(outerCircleCenter[0], outerCircleCenter[1] + SHADOW_DIM, outerCircleRadius, outerCircleShadowPaint);
        outerCircleShadowPaint.setStyle(Paint.Style.STROKE);
        final int numJitters = 7;
        for (int i = numJitters - 1; i > 0; --i) {
            outerCircleShadowPaint.setAlpha((int) ((i / (float) numJitters) * baseAlpha));
            c.drawCircle(outerCircleCenter[0], outerCircleCenter[1] + SHADOW_DIM ,
                    outerCircleRadius + (numJitters - i) * SHADOW_JITTER_DIM , outerCircleShadowPaint);
        }
    }

    void drawDebugInformation(Canvas c) {
        if (debugPaint == null) {
            debugPaint = new Paint();
            debugPaint.setARGB(255, 255, 0, 0);
            debugPaint.setStyle(Paint.Style.STROKE);
            debugPaint.setStrokeWidth(UiUtil.dp(getContext(), 1));
        }

        if (debugTextPaint == null) {
            debugTextPaint = new TextPaint();
            debugTextPaint.setColor(0xFFFF0000);
            debugTextPaint.setTextSize(UiUtil.sp(getContext(), 16));
        }

        // Draw wireframe
        debugPaint.setStyle(Paint.Style.STROKE);
        c.drawRect(textBounds, debugPaint);
        c.drawRect(targetBounds, debugPaint);
        c.drawCircle(outerCircleCenter[0], outerCircleCenter[1], 10, debugPaint);
        c.drawCircle(outerCircleCenter[0], outerCircleCenter[1], calculatedOuterCircleRadius - CIRCLE_PADDING, debugPaint);
        c.drawCircle(targetBounds.centerX(), targetBounds.centerY(), TARGET_RADIUS + TARGET_PADDING, debugPaint);

        // Draw positions and dimensions
        debugPaint.setStyle(Paint.Style.FILL);
        final String debugText =
                "Text bounds: " + textBounds.toShortString() + "
" +
                        "Target bounds: " + targetBounds.toShortString() + "
" +
                        "Center: " + outerCircleCenter[0] + " " + outerCircleCenter[1] + "
" +
                        "View size: " + getWidth() + " " + getHeight() + "
" +
                        "Target bounds: " + targetBounds.toShortString();

        if (debugStringBuilder == null) {
            debugStringBuilder = new SpannableStringBuilder(debugText);
        } else {
            debugStringBuilder.clear();
            debugStringBuilder.append(debugText);
        }

        if (debugLayout == null) {
            debugLayout = new DynamicLayout(debugText, debugTextPaint, getWidth(), Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false);
        }

        final int saveCount = c.save();
        {
            debugPaint.setARGB(220, 0, 0, 0);
            c.translate(0.0f, topBoundary);
            c.drawRect(0.0f, 0.0f, debugLayout.getWidth(), debugLayout.getHeight(), debugPaint);
            debugPaint.setARGB(255, 255, 0, 0);
            debugLayout.draw(c);
        }
        c.restoreToCount(saveCount);
    }

    void drawTintedTarget() {
        final android.graphics.drawable.Drawable icon = target.icon;
        if (!shouldTintTarget || icon == null) {
            tintedTarget = null;
            return;
        }

        if (tintedTarget != null) return;

        tintedTarget = Bitmap.createBitmap(icon.getIntrinsicWidth(), icon.getIntrinsicHeight(),
                Bitmap.Config.ARGB_8888);
        final Canvas canvas = new Canvas(tintedTarget);
        icon.setColorFilter(new PorterDuffColorFilter(
                outerCirclePaint.getColor(), PorterDuff.Mode.SRC_ATOP));
        icon.draw(canvas);
        icon.setColorFilter(null);
    }

    void updateTextLayouts() {
        final int textWidth = Math.min(getWidth(), TEXT_MAX_WIDTH) - TEXT_PADDING * 2;
        if (textWidth <= 0) {
            return;
        }

        titleLayout = new StaticLayout(title, titlePaint, textWidth,
                Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false);

        if (description != null) {
            descriptionLayout = new StaticLayout(description, descriptionPaint, textWidth,
                    Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false);
        } else {
            descriptionLayout = null;
        }
    }

    float halfwayLerp(float lerp) {
        if (lerp < 0.5f) {
            return lerp / 0.5f;
        }

        return (1.0f - lerp) / 0.5f;
    }

    float delayedLerp(float lerp, float threshold) {
        if (lerp < threshold) {
            return 0.0f;
        }

        return (lerp - threshold) / (1.0f - threshold);
    }

    void calculateDimensions() {
        textBounds = getTextBounds();
        outerCircleCenter = getOuterCircleCenterPoint();
        calculatedOuterCircleRadius = getOuterCircleRadius(outerCircleCenter[0], outerCircleCenter[1], textBounds, targetBounds);
    }

    void calculateDrawingBounds() {
        if (outerCircleCenter == null) {
            // Called dismiss before we got a chance to display the tap target
            // So we have no center -> cant determine the drawing bounds
            return;
        }
        drawingBounds.left = (int) Math.max(0, outerCircleCenter[0] - outerCircleRadius);
        drawingBounds.top = (int) Math.min(0, outerCircleCenter[1] - outerCircleRadius);
        drawingBounds.right = (int) Math.min(getWidth(),
                outerCircleCenter[0] + outerCircleRadius + CIRCLE_PADDING);
        drawingBounds.bottom = (int) Math.min(getHeight(),
                outerCircleCenter[1] + outerCircleRadius + CIRCLE_PADDING);
    }

    int getOuterCircleRadius(int centerX, int centerY, Rect textBounds, Rect targetBounds) {
        final int targetCenterX = targetBounds.centerX();
        final int targetCenterY = targetBounds.centerY();
        final int expandedRadius = (int) (1.1f * TARGET_RADIUS);
        final Rect expandedBounds = new Rect(targetCenterX, targetCenterY, targetCenterX, targetCenterY);
        expandedBounds.inset(-expandedRadius, -expandedRadius);

        final int textRadius = maxDistanceToPoints(centerX, centerY, textBounds);
        final int targetRadius = maxDistanceToPoints(centerX, centerY, expandedBounds);
        return Math.max(textRadius, targetRadius) + CIRCLE_PADDING;
    }

    Rect getTextBounds() {
        final int totalTextHeight = getTotalTextHeight();
        final int totalTextWidth = getTotalTextWidth();

        final int possibleTop = targetBounds.centerY() - TARGET_RADIUS - TARGET_PADDING - totalTextHeight;
        final int top;
        if (possibleTop > topBoundary) {
            top = possibleTop;
        } else {
            top = targetBounds.centerY() + TARGET_RADIUS + TARGET_PADDING;
        }

        final int relativeCenterDistance = (getWidth() / 2) - targetBounds.centerX();
        final int bias = relativeCenterDistance < 0 ? -TEXT_POSITIONING_BIAS : TEXT_POSITIONING_BIAS;
        final int left = Math.max(TEXT_PADDING, targetBounds.centerX() - bias - totalTextWidth);
        final int right = Math.min(getWidth() - TEXT_PADDING, left + totalTextWidth);
        return new Rect(left, top, right, top + totalTextHeight);
    }

    int[] getOuterCircleCenterPoint() {
        if (inGutter(targetBounds.centerY())) {
            return new int[]{targetBounds.centerX(), targetBounds.centerY()};
        }

        final int targetRadius = Math.max(targetBounds.width(), targetBounds.height()) / 2 + TARGET_PADDING;
        final int totalTextHeight = getTotalTextHeight();

        final boolean onTop = targetBounds.centerY() - TARGET_RADIUS - TARGET_PADDING - totalTextHeight > 0;

        final int left = Math.min(textBounds.left, targetBounds.left - targetRadius);
        final int right = Math.max(textBounds.right, targetBounds.right + targetRadius);
        final int titleHeight = titleLayout == null ? 0 : titleLayout.getHeight();
        final int centerY = onTop ?
                targetBounds.centerY() - TARGET_RADIUS - TARGET_PADDING - totalTextHeight + titleHeight
                :
                targetBounds.centerY() + TARGET_RADIUS + TARGET_PADDING + titleHeight;

        return new int[] { (left + right) / 2, centerY };
    }

    int getTotalTextHeight() {
        if (titleLayout == null) {
            return 0;
        }

        if (descriptionLayout == null) {
            return titleLayout.getHeight() + TEXT_SPACING;
        }

        return titleLayout.getHeight() + descriptionLayout.getHeight() + TEXT_SPACING;
    }

    int getTotalTextWidth() {
        if (titleLayout == null) {
            return 0;
        }

        if (descriptionLayout == null) {
            return titleLayout.getWidth();
        }

        return Math.max(titleLayout.getWidth(), descriptionLayout.getWidth());
    }
    boolean inGutter(int y) {
        if (bottomBoundary > 0) {
            return y < GUTTER_DIM || y > bottomBoundary - GUTTER_DIM;
        } else {
            return y < GUTTER_DIM || y > getHeight() - GUTTER_DIM;
        }
    }
    int maxDistanceToPoints(int x1, int y1, Rect bounds) {
        final double tl = distance(x1, y1, bounds.left, bounds.top);
        final double tr = distance(x1, y1, bounds.right, bounds.top);
        final double bl = distance(x1, y1, bounds.left, bounds.bottom);
        final double br = distance(x1, y1, bounds.right, bounds.bottom);
        return (int) Math.max(tl, Math.max(tr, Math.max(bl, br)));
    }
    double distance(int x1, int y1, int x2, int y2) {
        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }
    void invalidateViewAndOutline(Rect bounds) {
        invalidate(bounds);
        if (outlineProvider != null && Build.VERSION.SDK_INT >= 21) {
            invalidateOutline();
        }
    }
}


static class ViewUtil {

    ViewUtil() {}

    private static boolean isLaidOut(View view) {
        return true;
    }
    static void onLaidOut(final View view, final Runnable runnable) {
        if (isLaidOut(view)) {
            runnable.run();
            return;
        }
        final ViewTreeObserver observer = view.getViewTreeObserver();
        observer.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
            @Override
            public void onGlobalLayout() {
                final ViewTreeObserver trueObserver;
                if (observer.isAlive()) {
                    trueObserver = observer;
                } else {
                    trueObserver = view.getViewTreeObserver();
                }
                removeOnGlobalLayoutListener(trueObserver, this);
                runnable.run();
            }
        });
    }
    @SuppressWarnings("deprecation")
    static void removeOnGlobalLayoutListener(ViewTreeObserver observer,
                                             ViewTreeObserver.OnGlobalLayoutListener listener) {
        if (Build.VERSION.SDK_INT >= 16) {
            observer.removeOnGlobalLayoutListener(listener);
        } else {
            observer.removeGlobalOnLayoutListener(listener);
        }
    }
    static void removeView(ViewManager parent, View child) {
        if (parent == null || child == null) {
            return;
        }
        try {
            parent.removeView(child);
        } catch (Exception ignored) {
        }
    }
}

static class ViewTapTarget extends TapTarget {
    final View view;

    ViewTapTarget(View view, CharSequence title,  CharSequence description) {
        super(title, description);
        if (view == null) {
            throw new IllegalArgumentException("Given null view to target");
        }
        this.view = view;
    }

    @Override
    public void onReady(final Runnable runnable) {
        ViewUtil.onLaidOut(view, new Runnable() {
            @Override
            public void run() {
                // Cache bounds
                final int[] location = new int[2];
                view.getLocationOnScreen(location);
                bounds = new Rect(location[0], location[1],
                        location[0] + view.getWidth(), location[1] + view.getHeight());

                if (icon == null && view.getWidth() > 0 && view.getHeight() > 0) {
                    final Bitmap viewBitmap = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Bitmap.Config.ARGB_8888);
                    final Canvas canvas = new Canvas(viewBitmap);
                    view.draw(canvas);
                    icon = new android.graphics.drawable.BitmapDrawable(view.getContext().getResources(), viewBitmap);
                    icon.setBounds(0, 0, icon.getIntrinsicWidth(), icon.getIntrinsicHeight());
                }
                runnable.run();
                
public static class ArrowDownloadButton extends View {

    private static final int BLUE_ONE = Color.rgb(46, 164, 242);
    private static final int WHILE = Color.rgb(255, 255, 255);
    private static final float RADIUS = 180;
    private static final int TRI_POINT_NUMBER = 17;
    private static final float MAX_WAVE_HEIGHT = 10;
    private static final float MIN_WAVE_HEIGHT = 5;
    private static final int PROGRESS = 100;
    private static final int ANGLE = 360;
    private static final float TEXT_Y = 67.5f;
    private static final float OFFSET = 10;
    private static final float SMALL_RADIUS = 5;
    private static final float TEXT_SIZE = 40;
    private static final float ARC_WIDTH = 20;
    private static final float ARROW_WIDTH = 10;
    private static final float TRI_WIDTH = 10;
    private static final float LOADING_WIDTH = 10;

    private static final float STEP = 2;
    private static final float ELASTICITY_STEP = 10;
    private static final float ROPE_STEP_X = 30;
    private static final float ROPE_STEP_Y = 32;
    private static final float ROPE_HEAD_STEP_Y = 17;
    private static final float JUMP_STEP = 45;
    private static final float DOWN_STEP = 7.5f;
    private static final float TRI_STEP = 16.875f;
    private static final float TIME_STEP = 20;
    private static final float HOOK_STEP_Y = 15;
    private static final float HOOK_COUNT = 4;
    private static final float LITTLE_STEP = 8;
    private static final int DURATION = 20;
    private static final int COMPLETE_DURATION = 20;

    /**
     * start instance
     **/
    private static final String INSTANCE_STATE = "instance_state";
    /**
     *
     */
    private static final String X_I = "x";
    private static final String Y_I = "y";
    private static final String RADIUS_I = "radius";
    private static final String MAX_WAVE_HEIGHT_I = "max_wave_height";
    private static final String MIN_WAVE_HEIGHT_I = "min_wave_height";
    private static final String TEXT_Y_I = "text_y";
    private static final String STEP_I = "step";
    private static final String ELASTICITY_STEP_I = "elasticity_step";
    private static final String ROPE_STEP_X_I = "rope_step_x";
    private static final String ROPE_STEP_Y_I = "rope_step_y";
    private static final String ROPE_HEAD_STEP_Y_I = "rope_head_step_y";
    private static final String JUMP_STEP_I = "jump_step";
    private static final String DOWN_STEP_I = "down_step";
    private static final String TRI_STEP_I = "tri_step";
    private static final String HOOK_STEP_Y_I = "hook_step";
    private static final String LITTLE_STEP_I = "little_step";
    private static final String SMALL_RADIUS_I = "small_radius";
    private static final String TEXT_SIZE_I = "text_size";
    private static final String ARC_WIDTH_I = "arc_width";
    private static final String ARROW_WIDTH_I = "arrow_width";
    private static final String TRI_WIDTH_I = "tri_width";
    private static final String LOADING_WIDTH_I = "loading_width";
    private static final String IS_FIRST_I = "is_first";
    private static final String IS_ANIMATING_I = "is_animating";
    private static final String BEZIER_I = "bezier";
    private static final String IS_LOADING_I = "is_loading";
    private static final String IS_COMPLETED_I = "is_completed";
    private static final String IS_END_I = "is_end";
    private static final String COUNT_I = "count";
    private static final String LENGTH_I = "length";
    private static final String CURRENT_TIME_I = "current_time";
    private static final String WAVE_HEIGHT_I = "wave_height";
    private static final String PROGRESS_I = "progress";
    private static final String HOOK_COUNT_I = "hook_count";
    private static final String LENGTH_X_I = "length_x";
    private static final String LENGTH_Y_I = "length_y";


    private float x = 550;
    private float y = 550;
    private float radius = RADIUS;
    private float maxWaveHeight = MAX_WAVE_HEIGHT;
    private float minWaveHeight = MIN_WAVE_HEIGHT;
    private float textY = TEXT_Y;
    private float step = STEP;
    private float elasticityStep = ELASTICITY_STEP;
    private float ropeStepX = ROPE_STEP_X;
    private float ropeStepY = ROPE_STEP_Y;
    private float ropeHeadStepY = ROPE_HEAD_STEP_Y;
    private float jumpStep = JUMP_STEP;
    private float downStep = DOWN_STEP;
    private float triStep = TRI_STEP;
    private float hookStepY = HOOK_STEP_Y;
    private float littleStep = LITTLE_STEP;
    private float smallRadius = SMALL_RADIUS;
    private float textSize = TEXT_SIZE;
    private float arcWidth = ARC_WIDTH;
    private float arrowWidth = ARROW_WIDTH;
    private float triWidth = TRI_WIDTH;
    private float loadingWidth = LOADING_WIDTH;

    private Paint arrowPaint;
    private Paint arcPaint;
    private Paint smallPaint;
    private Paint triPaint;
    private Paint loadingPaint;
    private Paint textPaint;

    private Path arrowPath;
    private Path triPath;
    private Path textPath;

    private RectF oval;

    private Point a;
    private Point b;
    private Point c;
    private Point d;
    private Point e;
    private Point jumpPoint;

    private List<Point> triPoints = new ArrayList<>();

    private boolean isFirst = true;
    private boolean isAnimating = false;
    private boolean bezier = false;
    private boolean isLoading = false;
    private boolean isCompleted = false;
    private boolean isEnd = false;
    private int count = 0;
    private float length;
    private int currentTime = 0;
    private float waveHeight = MIN_WAVE_HEIGHT;
    private float progress = 0;
    private int hookCount = 0;
    float lengthX = 3 * radius / 4;
    float lengthY = 3 * radius / 4;

    public float getProgress() {
        return progress;
    }

    public void setProgress(float progress) {
        if (progress > 100) {
            this.progress = 100;
        } else {
            this.progress = progress;
        }

        if (progress == 100) {
            isLoading = false;
            isCompleted = true;
        }
    }

    public ArrowDownloadButton(Context context) {
        this(context, null);
    }

    public ArrowDownloadButton(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public ArrowDownloadButton(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init();
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        setMeasuredDimension(measure(widthMeasureSpec, true), measure(heightMeasureSpec, false));
    }

    private int measure(int measureSpec, boolean isWidth) {
        int result;
        int mode = MeasureSpec.getMode(measureSpec);
        int size = MeasureSpec.getSize(measureSpec);
        int padding = isWidth ? getPaddingLeft() + getPaddingRight() : getPaddingTop() + getPaddingBottom();
        if (mode == MeasureSpec.EXACTLY) {
            result = size;
        } else {
            result = isWidth ? getSuggestedMinimumWidth() : getSuggestedMinimumHeight();
            result += padding;
            if (mode == MeasureSpec.AT_MOST) {
                if (isWidth) {
                    result = Math.max(result, size);
                } else {
                    result = Math.min(result, size);
                }
            }
        }
        return result;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        if (isFirst) {
            init();
            isFirst = false;
        }
        canvas.drawCircle(x, y, radius, arcPaint);
        drawArrow(canvas);
        if (isAnimating) {
            animating();
        }
        if (isLoading) {
            loading(canvas);
        }
        if (isCompleted) {
            afterCompleted(canvas);
        }
    }

    private void init() {
        float temp = getHeight() > getWidth() ? getWidth() / 2 : getHeight() / 2;
        radius = temp - temp * OFFSET / RADIUS - temp * ELASTICITY_STEP / RADIUS - 6;
        x = getPaddingLeft() + getWidth() / 2;
        y = getPaddingTop() + getHeight() / 2;
        maxWaveHeight = convert(MAX_WAVE_HEIGHT);
        minWaveHeight = convert(MIN_WAVE_HEIGHT);
        textY = convert(TEXT_Y);
        step = convert(STEP);
        elasticityStep = convert(ELASTICITY_STEP);
        ropeStepX = convert(ROPE_STEP_X);
        ropeStepY = convert(ROPE_STEP_Y);
        ropeHeadStepY = convert(ROPE_HEAD_STEP_Y);
        jumpStep = convert(JUMP_STEP);
        downStep = convert(DOWN_STEP);
        triStep = convert(TRI_STEP);
        hookStepY = convert(HOOK_STEP_Y);
        littleStep = convert(LITTLE_STEP);
        smallRadius = convert(SMALL_RADIUS);
        textSize = convert(TEXT_SIZE);
        arcWidth = convert(ARC_WIDTH);
        arrowWidth = convert(ARROW_WIDTH);
        triWidth = convert(TRI_WIDTH);
        loadingWidth = convert(LOADING_WIDTH);
        lengthX = 3 * radius / 4;
        lengthY = 3 * radius / 4;

        arrowPath = new Path();
        triPath = new Path();
        textPath = new Path();
        oval = new RectF();
        oval.left = x - radius;
        oval.top = y - radius;
        oval.right = x + radius;
        oval.bottom = y + radius;
        length = radius / 2;
        initializePaints();
        initializePoints();
    }

    /**
     * start animating before loading
     */
    public void startAnimating() {
        isAnimating = true;
        invalidate();
    }

    /**
     * reset to initial state
     */
    public void reset() {
        isAnimating = false;
        isLoading = false;
        bezier = false;
        isCompleted = false;
        isEnd = false;
        length = radius / 2;
        count = 0;
        hookCount = 0;
        jumpPoint.x = -1;
        progress = 0;
        lengthX = 3 * radius / 4;
        lengthY = 3 * radius / 4;
        a.y = y + length;
        b.y = y - length;
        e.y = y + length;
        c.x = x - length / 2;
        c.y = y + length / 2;
        d.x = x + length / 2;
        d.y = y + length / 2;
        invalidate();
    }

    /**
     * animating
     */
    public void animating() {
        if (count < 19) {
            length = length * 3 / 4;
            a.y = y + length;
            b.y = y - length;

            if (((count + 1) % 3) == 0 && count < 9) {
                e.y = e.y + step;
                c.y = c.y + step;
                d.y = d.y + step;
            }
            if (count > 8 && count < 12) {
                jumpPoint.x = x;
                jumpPoint.y = y - jumpStep * (count - 8);
                c.x = c.x - ropeStepX;
                c.y = c.y - ropeHeadStepY;
                d.x = d.x + ropeStepX;
                d.y = d.y - ropeHeadStepY;
                e.y = e.y - ropeStepY;
            }
            if (count > 11) {
                bezier = true;
                if (count == 12) {
                    jumpPoint.y = jumpPoint.y - jumpStep * 2;
                } else {
                    jumpPoint.y = jumpPoint.y + downStep;
                    if (count < 16) {
                        int time1 = 15 - count;
                        e.y = y + time1 * elasticityStep;
                    }
                }
            }
            count++;
            postInvalidateDelayed(DURATION);
        } else {
            isAnimating = false;
            bezier = false;
            if (progress != 100) {
                isLoading = true;
            } else {
                isLoading = false;
                isCompleted = true;
            }
        }
    }

    /**
     * under loading
     *
     * @param canvas Target Canvas
     */
    private void loading(Canvas canvas) {
        Point currentPoint = triPoints.get(0);
        Point nextPoint;
        for (int i = 0; i < TRI_POINT_NUMBER; i++) {
            Point p = triPoints.get(i);
            p.x = (x - 3 * radius / 4) + triStep * i;
            p.y = y + calculateTri(TIME_STEP * i, currentTime);
        }
        for (int i = 1; i < TRI_POINT_NUMBER; i++) {
            nextPoint = triPoints.get(i);
            triPath.reset();
            triPath.moveTo(currentPoint.x, currentPoint.y);
            triPath.lineTo(nextPoint.x, nextPoint.y);
            canvas.drawCircle(nextPoint.x, nextPoint.y, smallRadius, smallPaint);
            canvas.drawPath(triPath, triPaint);
            currentPoint = nextPoint;
        }
        textPath.moveTo(x - textSize, y + textY);
        textPath.lineTo(x + textSize, y + textY);
        canvas.drawTextOnPath((int) progress + "%", textPath, 0, 0, textPaint);
        currentTime = (int) (currentTime + TIME_STEP);
        float sweepAngle = (progress / PROGRESS * ANGLE);
        canvas.drawArc(oval, 270, 0 - sweepAngle, false, loadingPaint);
        postInvalidateDelayed(DURATION);
    }

    /**
     * the method do such things:
     * 1.draw arrow.
     * 2.when animate was completed, let the small ball jump.
     *
     * @param canvas Target Canvas
     */
    protected void drawArrow(Canvas canvas) {
        if (jumpPoint.x != -1) {
            canvas.drawCircle(jumpPoint.x, jumpPoint.y, smallRadius, smallPaint);
        }
        if (bezier) {
            arrowPath.reset();
            arrowPath.moveTo(c.x, c.y);
            arrowPath.quadTo(e.x, e.y, d.x, d.y);
            canvas.drawPath(arrowPath, arrowPaint);
        }  else if (isLoading) {
        } else if (isCompleted) {
        }  else if (isEnd) {
            canvas.drawCircle(x, y, radius, loadingPaint);
            drawArrowOrHook(canvas);
        } else {
            arrowPath.reset();
            arrowPath.moveTo(a.x, a.y);
            arrowPath.lineTo(b.x, b.y);
            canvas.drawPath(arrowPath, arrowPaint);

            canvas.drawCircle(a.x, a.y, smallRadius, smallPaint);
            canvas.drawCircle(b.x, b.y, smallRadius, smallPaint);

            drawArrowOrHook(canvas);

        }
    }

    /**
     * draw arrow or hook
     *
     * @param canvas Target Canvas
     */
    private void drawArrowOrHook(Canvas canvas) {
        arrowPath.reset();
        arrowPath.moveTo(e.x, e.y);
        arrowPath.lineTo(c.x, c.y);
        canvas.drawPath(arrowPath, arrowPaint);
        arrowPath.reset();
        arrowPath.moveTo(e.x, e.y);
        arrowPath.lineTo(d.x, d.y);
        canvas.drawPath(arrowPath, arrowPaint);

        canvas.drawCircle(c.x, c.y, smallRadius, smallPaint);
        canvas.drawCircle(d.x, d.y, smallRadius, smallPaint);
        canvas.drawCircle(e.x, e.y, smallRadius, smallPaint);
    }

    /**
     * the animate after loading
     *
     * @param canvas Target Canvas
     */
    private void afterCompleted(Canvas canvas) {
        canvas.drawCircle(x, y, radius, loadingPaint);
        if (hookCount == HOOK_COUNT - 1) {
            e.y = e.y + littleStep;
            c.x = c.x - littleStep;
            d.x = d.x + littleStep;
            d.y = d.y - littleStep;
            isCompleted = false;
            isEnd = true;
        } else {
            e.x = x;
            e.y = y + hookStepY * (hookCount + 1);
            lengthX = lengthX * 3 / 4;
            c.x = x - lengthX * 3 / 4;
            c.y = y;
            d.x = x + lengthY - radius / (float) 8 * (hookCount + 1);
            d.y = y - hookStepY * (hookCount + 1);
            hookCount++;
        }
        drawArrowOrHook(canvas);
        postInvalidateDelayed(COMPLETE_DURATION);

    }

    protected void initializePaints() {
        arcPaint = new Paint();
        arcPaint.setAntiAlias(true);
        arcPaint.setStyle(Paint.Style.STROKE);
        arcPaint.setStrokeWidth(arcWidth);
        arcPaint.setColor(BLUE_ONE);

        arrowPaint = new Paint();
        arrowPaint.setAntiAlias(true);
        arrowPaint.setStyle(Paint.Style.STROKE);
        arrowPaint.setStrokeWidth(arrowWidth);
        arrowPaint.setColor(WHILE);

        smallPaint = new Paint();
        smallPaint.setAntiAlias(true);
        smallPaint.setStyle(Paint.Style.FILL);
        smallPaint.setColor(WHILE);

        triPaint = new Paint();
        triPaint.setAntiAlias(true);
        triPaint.setStyle(Paint.Style.STROKE);
        triPaint.setStrokeWidth(triWidth);
        triPaint.setColor(WHILE);

        loadingPaint = new Paint();
        loadingPaint.setAntiAlias(true);
        loadingPaint.setStyle(Paint.Style.STROKE);
        loadingPaint.setStrokeWidth(loadingWidth);
        loadingPaint.setColor(WHILE);

        textPaint = new Paint();
        textPaint.setAntiAlias(true);
        textPaint.setStyle(Paint.Style.FILL);
        textPaint.setStrokeWidth(1);
        textPaint.setColor(WHILE);
        textPaint.setTextSize(textSize);
    }

    protected void initializePoints() {
        a = new Point(x, y + radius / 2);
        b = new Point(x, y - radius / 2);
        c = new Point(x - radius / 4, y + radius / 4);
        d = new Point(x + radius / 4, y + radius / 4);
        e = new Point(x, y + radius / 2);
        jumpPoint = new Point();

        for (int i = 0; i < TRI_POINT_NUMBER; i++) {
            Point point = new Point();
            point.x = (x - 3 * radius / 4) + triStep * i;
            point.y = y + calculateTri(TIME_STEP * i, 0);
            triPoints.add(point);
        }
    }

    /**
     * calculate the wave
     *
     * @param originalTime original time
     * @param currentTime  current time
     * @return wave
     */
    private float calculateTri(float originalTime, float currentTime) {
        if (progress < PROGRESS / 3) {
            waveHeight = MIN_WAVE_HEIGHT;
        } else if (progress < PROGRESS * 2 / 3) {
            waveHeight = maxWaveHeight;
        } else {
            waveHeight = minWaveHeight;
        }
        return (float) (waveHeight * Math.sin((Math.PI / 80) * (originalTime + currentTime)));
    }

    private float convert(float original) {
        return radius * original / RADIUS;
    }

    @Override
    protected Parcelable onSaveInstanceState() {
        final Bundle bundle = new Bundle();
        bundle.putParcelable(INSTANCE_STATE, super.onSaveInstanceState());
        bundle.putFloat(X_I, x);
        bundle.putFloat(Y_I, y);
        bundle.putFloat(RADIUS_I, radius);
        bundle.putFloat(MAX_WAVE_HEIGHT_I, maxWaveHeight);
        bundle.putFloat(MIN_WAVE_HEIGHT_I, minWaveHeight);
        bundle.putFloat(TEXT_Y_I, textY);
        bundle.putFloat(STEP_I, step);
        bundle.putFloat(ELASTICITY_STEP_I, elasticityStep);
        bundle.putFloat(ROPE_STEP_X_I, ropeStepX);
        bundle.putFloat(ROPE_STEP_Y_I, ropeStepY);
        bundle.putFloat(ROPE_HEAD_STEP_Y_I, ropeHeadStepY);
        bundle.putFloat(JUMP_STEP_I, jumpStep);
        bundle.putFloat(DOWN_STEP_I, downStep);
        bundle.putFloat(TRI_STEP_I, triStep);
        bundle.putFloat(HOOK_STEP_Y_I, hookStepY);
        bundle.putFloat(LITTLE_STEP_I, littleStep);
        bundle.putFloat(SMALL_RADIUS_I, smallRadius);
        bundle.putFloat(TEXT_SIZE_I, textSize);
        bundle.putFloat(ARC_WIDTH_I, arcWidth);
        bundle.putFloat(ARROW_WIDTH_I, arrowWidth);
        bundle.putFloat(TRI_WIDTH_I, triWidth);
        bundle.putFloat(LOADING_WIDTH_I, loadingWidth);
        bundle.putBoolean(IS_FIRST_I, isFirst);
        bundle.putBoolean(IS_ANIMATING_I, isAnimating);
        bundle.putBoolean(BEZIER_I, bezier);
        bundle.putBoolean(IS_LOADING_I, isLoading);
        bundle.putBoolean(IS_COMPLETED_I, isCompleted);
        bundle.putBoolean(IS_END_I, isEnd);
        bundle.putInt(COUNT_I, count);
        bundle.putFloat(LENGTH_I, length);
        bundle.putInt(CURRENT_TIME_I, currentTime);
        bundle.putFloat(WAVE_HEIGHT_I, waveHeight);
        bundle.putFloat(PROGRESS_I, progress);
        bundle.putInt(HOOK_COUNT_I, hookCount);
        bundle.putFloat(LENGTH_X_I, lengthX);
        bundle.putFloat(LENGTH_Y_I, lengthY);
        return bundle;
    }

    @Override
    protected void onRestoreInstanceState(Parcelable state) {
        if (state instanceof Bundle) {
            final Bundle bundle = (Bundle) state;
            x = bundle.getFloat(X_I);
            y = bundle.getFloat(Y_I);
            radius = bundle.getFloat(RADIUS_I);
            maxWaveHeight = bundle.getFloat(MAX_WAVE_HEIGHT_I);
            minWaveHeight = bundle.getFloat(MIN_WAVE_HEIGHT_I);
            textY = bundle.getFloat(TEXT_Y_I);
            step = bundle.getFloat(STEP_I);
            elasticityStep = bundle.getFloat(ELASTICITY_STEP_I);
            ropeStepX = bundle.getFloat(ROPE_STEP_X_I);
            ropeStepY = bundle.getFloat(ROPE_STEP_Y_I);
            ropeHeadStepY = bundle.getFloat(ROPE_HEAD_STEP_Y_I);
            jumpStep = bundle.getFloat(JUMP_STEP_I);
            downStep = bundle.getFloat(DOWN_STEP_I);
            triStep = bundle.getFloat(TRI_STEP_I);
            hookStepY = bundle.getFloat(HOOK_STEP_Y_I);
            littleStep = bundle.getFloat(LITTLE_STEP_I);
            smallRadius = bundle.getFloat(SMALL_RADIUS_I);
            textSize = bundle.getFloat(TEXT_SIZE_I);
            arcWidth = bundle.getFloat(ARC_WIDTH_I);
            arrowWidth = bundle.getFloat(ARROW_WIDTH_I);
            triWidth = bundle.getFloat(TRI_WIDTH_I);
            loadingWidth = bundle.getFloat(LOADING_WIDTH_I);
            isFirst = bundle.getBoolean(IS_FIRST_I);
            isAnimating = bundle.getBoolean(IS_ANIMATING_I);
            bezier = bundle.getBoolean(BEZIER_I);
            isLoading = bundle.getBoolean(IS_LOADING_I);
            isCompleted = bundle.getBoolean(IS_COMPLETED_I);
            isEnd = bundle.getBoolean(IS_END_I);
            count = bundle.getInt(COUNT_I);
            length = bundle.getFloat(LENGTH_I);
            currentTime = bundle.getInt(CURRENT_TIME_I);
            waveHeight = bundle.getFloat(WAVE_HEIGHT_I);
            progress = bundle.getFloat(PROGRESS_I);
            hookCount = bundle.getInt(HOOK_COUNT_I);
            lengthX = bundle.getFloat(LENGTH_X_I);
            lengthY = bundle.getFloat(LENGTH_Y_I);
        }
        super.onRestoreInstanceState(state);
    }

    static class Point {
        public float x;
        public float y;

        public Point(float x, float y) {
            this.x = x;
            this.y = y;
        }

        public Point() {
            x = -1;
            y = -1;
        }
    }
}
  /*Download*/
   
String destination = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS) + "/";
String fileName = "AppName.apk";
destination += fileName;
final Uri uri = Uri.parse("file://" + destination);
java.io.File file = new java.io.File(destination);
if (file.exists()) file.delete();
String url = "URL Apk..";
DownloadManager.Request request = new DownloadManager.Request(Uri.parse(url));
request.setDescription("Updating..");
request.setTitle("Download");
request.setDestinationUri(uri);
final DownloadManager manager = (DownloadManager) getSystemService(Context.DOWNLOAD_SERVICE);
final long downloadId = manager.enqueue(request);

BroadcastReceiver onComplete = new BroadcastReceiver() {
public void onReceive(Context ctxt, Intent intent) {
Intent install = new Intent(Intent.ACTION_VIEW); 
install.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); 
install.setDataAndType(uri, manager.getMimeTypeForDownloadedFile(downloadId)); 
startActivity(install);
unregisterReceiver(this);
finish();
}};
registerReceiver(onComplete, new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE));


//Or Using Intent Only

Intent intent = new Intent(Intent.ACTION_VIEW);
intent.setDataAndType(Uri.fromFile(new java.io.File(Environment.getExternalStorageDirectory() + "/download/" + "app.apk")), "application/vnd.android.package-archive");
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
startActivity(intent);


//Use permission
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />

InjectionsRejectionsResultInsultingSolutionsResolutions(true),
            }
        });
    }
}
 } 

 /*MRBEASTTTTT!!!!*/
	 
", public CompanyPackageName(FollowPath)
  }
@FollowHTMLAndBomba
/*Follow Me For More Codes*/
https://discord.gg/8UTpjuk4
bombaexample@gmail.com
/*With Name*/
Twitter:@BombaExample
YouTube:https://youtube.com/@TheRealBomba553 
YoutubeHasTag:@TheRealBomba553
Instagrams:bombaYfrindlwErin
/*Follow Me For More Codes And Learning*/



     Made By Bomba